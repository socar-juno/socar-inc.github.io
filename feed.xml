<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="https://tech.socarcorp.kr/feed.xml" rel="self" type="application/atom+xml" /><link href="https://tech.socarcorp.kr/" rel="alternate" type="text/html" /><updated>2022-02-14T09:20:03+00:00</updated><id>https://tech.socarcorp.kr/feed.xml</id><title type="html">SOCAR Tech Blog</title><subtitle>쏘카 기술 블로그</subtitle><author><name>SOCAR</name></author><entry><title type="html">쏘카의 관제 장치(Control Device)가 하는 일</title><link href="https://tech.socarcorp.kr/mobility/2022/02/14/control-device-with-car-sharing.html" rel="alternate" type="text/html" title="쏘카의 관제 장치(Control Device)가 하는 일" /><published>2022-02-14T00:00:00+00:00</published><updated>2022-02-14T00:00:00+00:00</updated><id>https://tech.socarcorp.kr/mobility/2022/02/14/control-device-with-car-sharing</id><content type="html" xml:base="https://tech.socarcorp.kr/mobility/2022/02/14/control-device-with-car-sharing.html">&lt;p&gt;안녕하세요. 쏘카 커넥티드 플랫폼 그룹 커넥티드 디바이스팀 주노입니다.&lt;/p&gt;

&lt;p&gt;쏘카에서 운영되는 차량과 개인 소유의 차량은 어떠한 차이가 있을까요? 비대면으로 카셰어링을 운영하기 위해, 다양한 기술들이 쏘카 차량에 담겨있다는 사실 혹시 알고 계셨나요?&lt;/p&gt;

&lt;p&gt;원격으로도 차량의 예약 / 운행 / 반납이 가능하도록, 쏘카의 차량에는 일반 차량과 달리 다양한 IoT 장치들이 있습니다. 관제 장치, 블랙박스, 하이패스 등 겉으로 보기엔 일반 제품들과 유사한 모습입니다. 하지만 쏘카에는 다소 특별한 기능들을 가진 장치들이 차량 내부에 장착됩니다.&lt;/p&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;쏘카 차량의 관제 장치란&lt;/li&gt;
  &lt;li&gt;쏘카 차량의 관제 장치가 하는 일
    &lt;ul&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;차량의 데이터를 수집합니다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;차량의 문을 잠그고 열 수 있습니다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;다양한 통신 방법으로 데이터를 교환합니다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;외부에 노출된, 차량이라는 악조건을 견뎌야만 합니다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;맺으며&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;쏘카-차량의-관제-장치란&quot;&gt;쏘카 차량의 관제 장치란&lt;/h2&gt;

&lt;p&gt;관제 장치의 사전적 정의는 ‘본래의 역할을 수행하도록 관리하여 통제하는 장치’입니다. 비대면 카셰어링을 가능하게 하기 위해서는 차량을 관리하고 통제하는 장치가 필요합니다.&lt;/p&gt;

&lt;p&gt;개인이 소유한 차량과는 달리, 쏘카의 차량은 관제 장치를 장착함으로써 카셰어링 차량으로 변하게 됩니다. 고객이 차량을 예약하고, 주행하고, 반납하기 위해서는 차량의 위치나 차량의 상태가 자동으로 확인되어야 하며, 예약한 고객이 스마트키를 들고 있지 않더라도 차량을 이용할 수 있도록 차량의 문을 열고 잠글 수 있어야하기 때문입니다.&lt;/p&gt;

&lt;p&gt;이번 글에서는 쏘카에서 운영하는 1만 7천대의 차량에 장착된 다양한 장치들 중 관제 장치에 관해 다루고자 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/control-device-with-car-sharing/sts-1-app.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/control-device-with-car-sharing/sts-0-schematic.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;쏘카-차량의-관제-장치가-하는-일&quot;&gt;쏘카 차량의 관제 장치가 하는 일&lt;/h2&gt;

&lt;h3 id=&quot;1-차량의-데이터를-수집합니다&quot;&gt;1. 차량의 데이터를 수집합니다.&lt;/h3&gt;

&lt;p&gt;차량의 정보를 수집하여, 비대면으로 예약 / 반납이 가능할 수 있는 기능들이 숨겨져 있습니다. 
쏘카에는 40여 종에 달하는, 다양한 차종들이 있습니다. 차량의 위치는 어디에 있는지, 반납시 차량 시동은 잘 꺼져있는지, 주유량이나 전기차 충전량은 충분한지, 문은 제대로 잘 잠기고 열리는지, 원격에서 실시간으로 확인이 되어야 비대면 카셰어링 서비스가 가능합니다.
데이터를 수집할 때 있어 보안에도 신경써야합니다. 특히 고객의 개인정보, 위치 정보 데이터가 대표적으로 그렇습니다. 이런 데이터는 정보보호 및 개인정보보호 관리체계인증(ISMS-P)에 따라 보안을 철저히하여 숨겨져 있으며, 권한을 가진 일부 직원들만 해당 정보를 조회할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/control-device-with-car-sharing/sts-2-data.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;차량의 데이터를 수집해서 고객의 편리한 운행을 돕는 것 뿐만 아니라, 보다 효율적으로 차량을 운영하고 관리할 수 있습니다. 예를 들어 차량 내부의 다양한 센서 및 ECU(Electronic Control Unit)로 부터 수집되는 신호들도 수집하여 데이터를 기반으로 용 중인 차량, 시스템, 장치에 대해 이상 징후 및 안정성을 관리(PHM, Prognostics and Health Management)를 할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;2-차량의-문을-잠그고-열-수-있습니다&quot;&gt;2. 차량의 문을 잠그고 열 수 있습니다.&lt;/h3&gt;

&lt;p&gt;쏘카의 비대면 서비스를 위해선 근거리 뿐만 아니라, 원거리에서도 차량을 제어할 수 있어야 합니다.
일반적인 차량에서는 스마트키를 통해 차량의 문을 열고 잠글 수 있으며, 스마트키를 차량 실내에 두어야만 차량의 시동을 걸 수 있습니다.
쏘카에는 스마트폰만으로도 차를 열고 잠글 수 있어야 하는데, 이 때 관제 장치가 차량의 문을 열고 닫는 명령하는 역할을 담당합니다. 
또한 고객 분들이 차량의 위치를 보다 편하게 찾을 수 있도록, 스마트폰으로도 비상등을 켜거나 경적(Horn)을 울릴 때에도 관제 장치가 사용됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/control-device-with-car-sharing/sts-3-app.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-다양한-통신-방법으로-데이터를-교환합니다&quot;&gt;3. 다양한 통신 방법으로 데이터를 교환합니다.&lt;/h3&gt;

&lt;p&gt;쏘카의 관제 장치는 스마트폰처럼 LTE나 3G 통신을 통해 쏘카의 서버와 메시지를 교환하게 됩니다. 이를 통해 서버는 차량 제어에 관한 데이터를 수집하게 됩니다.&lt;/p&gt;

&lt;p&gt;LTE/3G 네트워크 망은 전국적으로 통신사의 전파 중계기가 설치되어 있어 대부분의 지역에서 네트워크 연결이 가능합니다. 하지만 전파 중계 설비가 고장났거나, 네트워크 전파가 미처 닿지 않는 통신 음영 지역에서는 데이터 송수신이 잠시 끊기는 경우가 있습니다. 이를 막기 위해 쏘카에서는 또 다른 무선 통신 기술도 사용합니다. 블루투스는 2.4~2.485GHz의 극초단파를 사용한 개인 근거리 무선 통신 산업 표준 규격입니다. 쏘카의 관제 장치는 BLE 5.0 통신이 가능하여 지하주차장, 산지, 바다지역 등 3G/LTE 통신이 매우 약한 지역에서도 문제없이 차량을 제어할 수 있습니다. 그리고 근거리에서 차량 제어시, 스마트폰의 블루투스를 켤 경우 켜지 않았을 때 보다 더 빠르게 차량을 제어할 수 있습니다.&lt;/p&gt;

&lt;p&gt;블루투스 통신을 통해, 스마트폰 뿐만 아니라 다양한 전자 장치와도 무선 통신이 가능합니다. 이를 통해 차량 내/외부, 도로와 주차장 등 다양한 환경에서의 센서나 장치로부터, 무선으로 데이터를 수집할 수 있습니다. 보다 정확하게 차량의 위치를 찾거나, 차량에 장착된 센서로부터 데이터를 획득하고, 인프라의 다양한 정보들을 수집하거나 데이터를 교환할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;4-외부에-노출된-차량이라는-악조건을-견뎌야만-합니다&quot;&gt;4. 외부에 노출된, 차량이라는 악조건을 견뎌야만 합니다.&lt;/h3&gt;

&lt;p&gt;실내와는 달리 쏘카의 차량은 자연 환경에 노출되어 있습니다. 운전 중 일때의 수 많은 진동, 여름에는 90도 겨울에는 -20도 까지 변하는 온도, 비오는 날에는 엄청난 습기까지 일반적인 전자장비는 곧바로 고장이 날 수 밖에 없는 극한의 조건입니다.&lt;/p&gt;

&lt;p&gt;악조건에서도 정상적인 운용이 가능할 수 있도록 쏘카 차량내 장치들은 &lt;a href=&quot;https://www.koreascience.or.kr/article/JAKO202129159578200.pdf&quot;&gt;AEC-Q100&lt;/a&gt;같은 인증을 득하거나, 인증 규격 이상의 성능을 가져야만 합니다. (인증은 환경 시험(Environmental Test, 저/고온, 열 충격시험 등), 기구시험(Mechanical Test, 진동 낙하 충격 시험 등), 전기적 성능시험(Electrical Test, 작동 전압, 전원 순단 및 전압 변동시험)을 통해 장치의 성능을 평가하게 됩니다.)&lt;/p&gt;

&lt;p&gt;220V 콘센트가 아니라 차량의 배터리를 사용할 수 밖에 없는 차량 내 전자 장치들은 전기를 공급 받는 것 조차도 엄청나게 힘든 일일 수 밖에 없습니다. 모든 전자 장비는 회로에서 전자기 노이즈가 발생하며, 이 정도가 심한 경우 다른 전자 장치가 영향을 받아 오작동을 하거나 고장날 수도 있습니다. 차량에 설치되는 장치들인 만큼, 장착된 장비들이 전자 장치간 간섭(EMI/EMC)로 인한 영향을 방지하기위해, &lt;a href=&quot;https://www.rra.go.kr/FileDownSvl?file_type=LAWKR&amp;amp;file_parentseq=113&amp;amp;file_seq=1&quot;&gt;표준 인증(KN41)&lt;/a&gt;을 득하거나 표준 규격보다도 더 낮은 양의 전자기 노이즈만 발생시키도록 해야합니다.&lt;/p&gt;

&lt;p&gt;이러한 악조건 속에서도 서비스가 가능할 수 있도록, 관제 장치에는 개발, 제조, 납품, 장착, AS 전반에 걸쳐 다양한 노하우와 기술이 포함되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/control-device-with-car-sharing/sts-4-env.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/control-device-with-car-sharing/sts-5-soldering.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;맺으며&quot;&gt;맺으며&lt;/h2&gt;

&lt;p&gt;쏘카의 손으로 제작된 관제 장치는 2020년 처음 장착된 이래 10,000대가 넘는 차량에 장착되었습니다.
관제 장치는 약 6천만 시간 동안, 57만 명의 고객들의 176만 번의 차량 운행을 가능하게 하였으며 2억 Km의 거리의 여정동안 3천만 번의 제어를 수행하고 6억 개의 데이터셋을 수집하였습니다.&lt;/p&gt;

&lt;p&gt;쏘카 차량 내부에는 쏘카에서 직접 제작한 관제 장치 뿐만 아니라, 고객이 보다 편하고 효율적으로 차량을 운영할 수 있도록 하기 위해 또 다른 장치들이 장착되어 있습니다.
다음 글에서는 운전 편의를 위한 장치에 대해서 소개드리겠습니다.&lt;/p&gt;</content><author><name>juno</name></author><category term="mobility" /><category term="iot" /><summary type="html">안녕하세요. 쏘카 커넥티드 플랫폼 그룹 커넥티드 디바이스팀 주노입니다.</summary></entry><entry><title type="html">차량용 단말을 위한 IoT 파이프라인 구축기 (feat. Kafka) #2</title><link href="https://tech.socarcorp.kr/mobility/2022/02/09/socar-iot-pipeline-2.html" rel="alternate" type="text/html" title="차량용 단말을 위한 IoT 파이프라인 구축기 (feat. Kafka) #2" /><published>2022-02-09T01:00:00+00:00</published><updated>2022-02-09T01:00:00+00:00</updated><id>https://tech.socarcorp.kr/mobility/2022/02/09/socar-iot-pipeline-2</id><content type="html" xml:base="https://tech.socarcorp.kr/mobility/2022/02/09/socar-iot-pipeline-2.html">&lt;div class=&quot;photo-copyright&quot;&gt;
Photo by &lt;a href=&quot;https://unsplash.com/@selimarda?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;SELİM ARDA ERYILMAZ&lt;/a&gt; on &lt;a href=&quot;https://unsplash.com/photos/XYeCKHcZNz8?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;안녕하세요. 데이터 엔지니어링 그룹 모비딕 팀의 바다, 올리버입니다.
&lt;a href=&quot;https://tech.socarcorp.kr/mobility/2022/01/06/socar-iot-pipeline-1.html&quot;&gt;차량용 단말을 위한 IoT 파이프라인 구축기 #1&lt;/a&gt;에 이어, 차량에서 수집한 정보를 전사적으로 활용할 수 있도록 어떻게 단말 파이프라인을 설계하고 만들어 가는지에 대해 자세히 이야기하려고 합니다.&lt;/p&gt;

&lt;p&gt;이 글은 다음과 같은 분들에게 도움이 됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;데이터 파이프라인 구축에 관심 있는 개발자&lt;/li&gt;
  &lt;li&gt;차량의 정보 수집과 데이터 흐름에 관심 있는 분&lt;/li&gt;
  &lt;li&gt;AWS IoT Core, MSK(Managed Streaming for Apache Kafka) 솔루션에 관심 있는 개발자&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#쏘카의-첫-단말-파이프라인을-소개합니다-&quot;&gt;쏘카의 첫 단말 파이프라인을 소개합니다 &lt;a name=&quot;introduce&quot;&gt;&lt;/a&gt;&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#기존-단말-파이프라인&quot;&gt;기존 단말 파이프라인&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#기존-파이프라인의-한계&quot;&gt;기존 파이프라인의 한계&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#한계를-넘기-위한-신규-파이프라인-설계&quot;&gt;한계를 넘기 위한 신규 파이프라인 설계&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#본격적으로-신규-단말-파이프라인을-구축해봅시다-&quot;&gt;본격적으로 신규 단말 파이프라인을 구축해봅시다 &lt;a name=&quot;build&quot;&gt;&lt;/a&gt;&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#kafka-클러스터&quot;&gt;Kafka 클러스터&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#producer&quot;&gt;Producer&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#iot-core의-메시지-생성&quot;&gt;IoT Core의 메시지 생성&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#텔레매틱스-서버의-메시지-생성&quot;&gt;텔레매틱스 서버의 메시지 생성&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#consumer&quot;&gt;Consumer&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#kafka-connect&quot;&gt;Kafka Connect&lt;/a&gt;
            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#s3-sink-connector&quot;&gt;S3 Sink Connector&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#elasticsearch-sink-connector&quot;&gt;Elasticsearch Sink Connector&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#단말-차량-converter&quot;&gt;단말-차량 Converter&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#단말-파이프라인-모니터링-&quot;&gt;단말 파이프라인 모니터링 &lt;a name=&quot;monitoring&quot;&gt;&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#마치며-&quot;&gt;마치며 &lt;a name=&quot;wrap-up&quot;&gt;&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;쏘카의-첫-단말-파이프라인을-소개합니다-&quot;&gt;쏘카의 첫 단말 파이프라인을 소개합니다 &lt;a name=&quot;introduce&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&quot;기존-단말-파이프라인&quot;&gt;기존 단말 파이프라인&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/img/iot-pipeline-2/pipeline-prev.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;과거에는 차량에서 수집한 정보를 HTTPS 프로토콜을 이용해 쏘카의 텔레매틱스 서버에 전달했습니다. 텔레매틱스 서버에서 단말 데이터를 수집, 가공, 적재하는 작업의 일환으로 파이프라인에 단말 데이터를 투입했습니다. 텔레매틱스 서버는 쏘카 서비스의 원활한 운영과 고객 불편의 최소화를 위해 차량에서 수집한 정보를 최대한 빠른 시간 안에 처리하여야 합니다.&lt;/p&gt;

&lt;p&gt;단말이 차량에서 수집한 정보의 종류에 따라 텔레매틱스 서버의 다른 엔드포인트에 이를 보고합니다. 예를 들어 일반적인 차량 정보의 주기적 보고의 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;/log&lt;/code&gt; 엔드포인트로, 단말 재부팅시에  대한 보고는 &lt;code class=&quot;highlighter-rouge&quot;&gt;/boot&lt;/code&gt; 엔드포인트로 보고하는 방식입니다.&lt;/p&gt;

&lt;p&gt;차량에서 수집한 정보를 보고받은 텔레매틱스 서버는 이 정보를 서비스 운영을 위해 데이터베이스의 차량 정보 스키마에 맞추어 변환하여 데이터베이스에 적재합니다. 이렇게 변환하는 과정에서 운영에 꼭 필요한 데이터만을 필터링해 적재하기 때문에, 운영에는 충분한 정보를 가지고 있지만 연구와 분석을 위해 사용하기에는 한계가 있습니다.&lt;/p&gt;

&lt;p&gt;따라서 연구, 분석에도 차량에서 수집한 정보를 충분히 활용할 수 있도록 필터링 되지 않은 데이터를 AWS Kinesis에 흘려보냅니다. Kinesis는 실시간으로 데이터 스트림을 수집하고 처리, 분석하는 데에 사용하는 AWS의 솔루션입니다. 당시 Kinesis를 선택했던 이유는 데이터 스트림에 대한 관리와 개발을 최소화하면서도 차량에서 수집한 정보를 필요한 곳에서 최대한으로 활용하고자 했던 선택이었습니다.&lt;/p&gt;

&lt;p&gt;이렇게 Kinesis Stream에 전달된 차량에서 수집한 정보는 Kinesis Firehose를 거쳐 각각 Elasticsearch, S3, BigQuery에 저장하여 활용하고 있었습니다.&lt;/p&gt;

&lt;h3 id=&quot;기존-파이프라인의-한계&quot;&gt;기존 파이프라인의 한계&lt;/h3&gt;
&lt;p&gt;하지만 단순히 ‘수집 정보를 흘려보내기만 하면 되겠다’라고 가볍게 여겼던 Kinesis는 생각보다 많은 관리가 필요했고, Kinesis Stream을 사용하는 프로젝트가 늘어날수록 파이프라인은 점점 복잡해졌습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/iot-pipeline-2/pipeline-bang.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기본적으로 Elasticsearch와 S3, BigQuery에 적재하는 것 외에도, 전사에서 필요한 용도에 따라 단말 수집 정보가 실시간으로 수집되는 Kinesis Stream에 Consumer를 연결하여 활용할 수 있었습니다. 그러나 이 파이프라인을 관리하는 주체가 없어서 불필요하게 많은 Consumer가 연결되었습니다. &lt;strong&gt;Kinesis 스트림에 많은 Lambda 함수, 많은 Process들이 붙었고 Kinesis Stream에 병목이 생기는 경우가 생겼습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;더 많은 처리량을 위해 샤드(샤드 당 1초에 최대 2MB의 데이터 처리)를 늘려보기도 하고, 향상된 팬아웃 기능을 사용하여 극복할 수 있었지만 이는 비용 증가와 직결되며, 근본적인 해결책도 아니었습니다.&lt;/p&gt;

&lt;h3 id=&quot;한계를-넘기-위한-신규-파이프라인-설계&quot;&gt;한계를 넘기 위한 신규 파이프라인 설계&lt;/h3&gt;
&lt;p&gt;Server-side Application의 업데이트는 보통 즉각적인 효과를 발휘하지만, 사용자의 PC에 설치되는 소프트웨어나 하드웨어의 펌웨어는 상황에 따라 업데이트에 상당한 시간을 필요로 합니다. 쏘카의 단말 펌웨어 업데이트도 항상 쉽지 않은 일입니다.&lt;/p&gt;

&lt;p&gt;차량에 명령을 내리는 명령 채널에 &lt;a href=&quot;https://aws.amazon.com/ko/iot-core&quot;&gt;IoT Core&lt;/a&gt;를 사용하게 되면서, 보고 채널에도 IoT Core로 갈아탈 수 있는 기회가 왔고, 기존 파이프라인의 한계점을 개선할 수 있는 절호의 찬스를 맞이했습니다! 그리하여 발 빠르게 신규 파이프라인 설계에 착수했습니다. 설계하면서 중점을 두었던 주제들은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;단말 수집 정보를 수집-가공-저장하던 텔레매틱스 서버를 은퇴시키자
    &lt;ul&gt;
      &lt;li&gt;텔레매틱스 서버는 그동안 단말 데이터 처리를 위해 수고해주었지만, 장애가 발생하면 파이프라인의 병목이 되는 원인이기도 했습니다. 이는 파이프라인의 흐름에 치명적일 수 있어 용도를 최소화하거나 은퇴시키고자 했습니다.&lt;/li&gt;
      &lt;li&gt;IoT Core를 사용하면서 프로토콜이 제한적인 HTTP 프로토콜 통신을 걷어내고 대용량의 데이터를 전송하기 적합한 MQTT 프로토콜 통신을 사용할 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;전사에서 Kafka를 사용하는 분위기에 발맞추어, 데이터 스트리밍 플랫폼의 최강자인 Kafka를 사용하자
    &lt;ul&gt;
      &lt;li&gt;모비딕 팀뿐만 아니라 전사에서 Kafka를 도입하고자 하는 준비 과정이 있었고, Kafka에 대한 사내 지식이 쌓여가고 공유하고 있었기 때문에 이 또한 좋은 기회라고 생각했습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;하나로 통합되어 있던 토픽을 관심 분류에 따라 여러 토픽으로 나누어 사용하자
    &lt;ul&gt;
      &lt;li&gt;기존 파이프라인에서는 차량에서 수집한 정보를 저장되는 데에 하나의 토픽을 사용하고 있었습니다. 이 때문에 스트림 내의 차량 수집 정보를 특정 프로젝트 내에서 사용하기 위해서는 프로젝트에 불필요한 정보도 일단 모두 읽어야 하는 문제가 있었습니다. 이러한 비효율을 제거하고자, 단말 수집 정보의 토픽을 관심사별로 분리하고자 했습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시스템 부하가 일으키는 장애에 대한 걱정 없이 신규 서비스를 개발하자
    &lt;ul&gt;
      &lt;li&gt;Kinesis 파이프라인에서 Throttling이 지속적으로 발생하면서 Kinesis와 연결하여 사용하려던 신규 서비스를 투입하는 것도 굉장히 부담스러워졌습니다. 이를 극복하면서 신규 서비스 개발에도 데이터 스트림이 걸림돌이 되지 않았으면 했습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MSK를 사용하여, 운영 리소스를 최소화하자
    &lt;ul&gt;
      &lt;li&gt;우리의 리소스를 고려한다면 Kafka 운영을 위한 리소스가 추가 투입되는 것도 부담스러운 요소 중 하나였습니다. AWS에서 완전 관리형 Kafka 서비스인 MSK를 제공하고 있습니다. MSK 덕분에 Kafka를 직접 사용하면서 운영 리소스를 최소화하며 빠르게 요구사항을 충족할 수 있겠다고 생각했습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터 파이프라인의 토픽, 파티션 등의 세부 설정을 우리가 직접 하여 상황에 맞게 사용할 수 있도록 하자&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이런 목표들을 가지고 설계한 파이프라인을 통해 차량에서 수집한 정보를 보고받고, MSK의 토픽에 정보가 담긴 메시지를 전달하며, 각각의 Consumer가 MSK에 붙어 필요한 데이터들을 가져갈 수 있는 기존보다 안정적인 새로운 파이프라인을 구성하기로 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/iot-pipeline-2/pipeline-next.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 본격적으로 파이프라인을 구현해볼까요?&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;본격적으로-신규-단말-파이프라인을-구축해봅시다-&quot;&gt;본격적으로 신규 단말 파이프라인을 구축해봅시다 &lt;a name=&quot;build&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;쏘카의 신규 단말 파이프라인은 크게 토픽을 관리하며 메시지를 저장하는 Kafka 클러스터와 메시지를 생산하는 Producer, 메시지를 소비하는 Consumer 세 가지로 구성됩니다.&lt;/p&gt;

&lt;h3 id=&quot;kafka-클러스터&quot;&gt;Kafka 클러스터&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/iot-pipeline-2/create-msk-cluster.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Kafka 클러스터는 AWS MSK를 통해 쉽게 구축할 수 있었습니다. 사용하고자 하는 인스턴스와 브로커 당 용량 및 Kafka의 버전, 보안 설정만 거치면 쉽게 클러스터를 구축할 수 있습니다.&lt;/p&gt;

&lt;p&gt;주의할 점은 생성 후 클러스터의 설정 변경에 제약이 있다는 점입니다. 예를 들어 인스턴스의 타입은 자유롭게 Up &amp;amp; Down이 가능하나, 브로커의 수량과 브로커의 용량은 증설만 가능합니다. (이 부분을 놓쳐 초기에 클러스터를 여러 번 새로 만드는 고생하기도 했습니다)&lt;/p&gt;

&lt;p&gt;스토리지의 경우 그동안 기존 파이프라인을 운영했던 데이터에 기반하여 최대 피크 수준도 버틸 수 있도록 설정했습니다. 이를 넘어서서 스토리지가 꽉 차게 되면 메시지가 유실되는 문제가 발생합니다. 이런 문제를 겪지 않도록 MSK에서는 스토리지 오토스케일링 기능을 제공합니다. 전체 용량의 10~80%에 도달하면 Auto Scaling이 되도록 설정이 가능합니다. 다만 안타깝게도 오토 스케일링도 스케일링 업만 가능하며 다운은 불가능하다는 점 유의하셔야 합니다.&lt;/p&gt;

&lt;p&gt;마지막으로 Cluster Configuration을 통해 Kafka 클러스터 설정을 할 수 있습니다. Kafka는 스트리밍 데이터 처리 플랫폼으로 데이터를 영구 저장할 수도 있지만 보통은 메시지의 저장 기간을 정해놓고 사용합니다. 장애가 발생해도 2일 이내에 해결하겠다는 마음으로 48시간(2일)로 설정했습니다. 이외 자세한 설정값들은 &lt;a href=&quot;https://kafka.apache.org/documentation/&quot;&gt;Kafka 문서&lt;/a&gt;를 참고해주세요.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;log.cleanup.policy&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;delete&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;log.retention.hours&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;48&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 기본적인 클러스터 설정이 끝나면 수분 내에 Kafka 클러스터가 생성됩니다. 이제 메시지를 위한 토픽을 만들어주어야겠죠. 로컬 머신에 MSK와 같은 버전(권장)의 Kafka를 다운로드하시면 기본적으로 제공하는 CLI를 이용하여 토픽을 생성할 수 있습니다. (또는 원하는 언어의 Kafka 클라이언트를 통해서도 생성할 수 있어요!)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/bin/kafka-topics.sh --create \
    --zookeeper &amp;lt;주키퍼 호스트&amp;gt;:&amp;lt;주키퍼 포트&amp;gt; \
    --topic &amp;lt;토픽 이름&amp;gt; \
    --partitions &amp;lt;파티션 수&amp;gt; \
    --replication-factor &amp;lt;복제 팩터&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;참고로 &lt;code class=&quot;highlighter-rouge&quot;&gt;auto.create.topics.enable&lt;/code&gt; 설정을 켜두면 자동으로 토픽을 생성하게 할 수 있습니다. 저희는 무분별하게 토픽이 생성되는 것을 막고자 이 방식은 사용하지 않았습니다.&lt;/p&gt;

&lt;p&gt;토픽 생성 시에는 토픽 이름, 파티션의 개수, 복제 팩터를 설정하게 됩니다.&lt;/p&gt;

&lt;p&gt;Kafka는 토픽에 메시지를 저장할 때 파일 시스템을 사용하기 때문에, 파티션을 하나로 지정하면 브로커의 I/O에 따라 성능이 좌지우지됩니다. 따라서 클러스터의 브로커 수, 데이터의 크기, Consumer의 수 같은 요소를 적절하게 고려하여 파티션의 수량을 정해야 합니다.&lt;/p&gt;

&lt;p&gt;복제 팩터는 중요한 설정 중 하나로, 하나의 파티션이 몇 개까지 복제될지를 설정하는 수치입니다. MSK는 중요 보안 업데이트나 설정 변경 시에 브로커를 한 대씩 차례차례 재부팅합니다. 이때 복제 팩터가 1인 경우 해당 파티션이 있는 브로커가 업데이트 등으로 인해 잠시 OFF되어 있을 때 Producer가 해당 파티션에 데이터를 쓰려고 하면 데이터 유실이 발생할 수 있습니다. 이러한 문제 없이 운영하기 위해서는 복제 팩터를 최소 2 이상으로 설정해 주셔야 합니다. 2 이상으로 설정한 경우, 기존 파티션 Leader를 가지고 있던 브로커가 OFF 되어도 복제본을 갖고 있던 다른 브로커가 파티션 Leader를 넘겨받아 Kafka 클러스터가 다운타임 없이 정상적으로 역할을 수행해냅니다.&lt;/p&gt;

&lt;h3 id=&quot;producer&quot;&gt;Producer&lt;/h3&gt;
&lt;p&gt;Kafka 클러스터가 준비되었으니, 메시지를 생산할 Producer를 설정해 보겠습니다. 엄밀히 말하면 단말에서 차량 정보를 수집하여 전달하는 부분을 Producer라고 볼 수도 있겠지만, 여기서는 Kafka 클러스터를 기준으로 하여, Kafka에 메시지를 생성하는 부분을 Producer의 역할로 정의하겠습니다.&lt;/p&gt;

&lt;p&gt;위에서 말씀드린 것처럼, &lt;strong&gt;단말의 펌웨어는 Server-side Application처럼 어느 시점에 한 번에 업데이트하기 어렵습니다&lt;/strong&gt;. 빨라도 몇 주에서 오래 걸리면 몇 달은 길게 두고 보아야 하는 작업입니다. 이렇게 짧지 않은 기간동안 보고 채널이 파편화되어 있는 동안에도 파이프라인에는 펌웨어 구분 없이 모든 차량에서 수집한 정보가 적재되어야 했습니다. 그렇게 하기 위해 IoT Core의 메시지 생성과 텔레매틱스 서버의 메시지 생성을 모두 구현하게 되었습니다.&lt;/p&gt;

&lt;h4 id=&quot;iot-core의-메시지-생성&quot;&gt;IoT Core의 메시지 생성&lt;/h4&gt;
&lt;p&gt;먼저 신규 펌웨어에서 IoT Core로 차량에서 수집한 정보를 전달하는 경우를 살펴보겠습니다. 단말에서는 차량 정보를 수집하여 IoT Core의 특정 토픽에 보고합니다. 그리고 IoT Core Rule을 만들어 이 정보를 구독할 수 있습니다. 예를 들어 단말은 &lt;code class=&quot;highlighter-rouge&quot;&gt;report&lt;/code&gt;라는 토픽에 차량 정보를 보고하고, IoT Core Rule에 &lt;code class=&quot;highlighter-rouge&quot;&gt;report&lt;/code&gt; 토픽을 구독하도록 Rule을 생성했다면, 새로운 차량 정보 메시지가 보고될 때마다 Rule에 설정된 작업이 실행됩니다.&lt;/p&gt;

&lt;p&gt;IoT Core Rule에 대해 자세히 알아볼까요? IoT Core Rule은 익숙한 SQL 쿼리(정확히는 AWS IoT Core SQL)를 통해 입맛에 맞게 단말에서 보고한 데이터를 가공할 수 있으며, 다른 데이터 시스템으로 전달하는 역할을 수행합니다. 신규 단말 파이프라인에서는 단말에서 JSON 형식의 메시지를 전달받고, 여기에 SQL을 이용하여 Timestamp를 추가해 사용합니다. 이를 위해 다음과 같은 쿼리문을 사용합니다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&quot;yyyy-MM-dd'T'HH:mm:ssz&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;timestamp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;timestamp&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'report'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;AWS IoT Core SQL에서 지원하는 SQL 구문은 일반적인 SQL 구문과 비슷하지만 다를 수 있으니, 자세한 내용은 AWS에서 제공하는 &lt;a href=&quot;https://docs.aws.amazon.com/iot/latest/developerguide/iot-sql-reference.html&quot;&gt;AWS IoT Core SQL 레퍼런스&lt;/a&gt;를 참고하시기 바랍니다. IoT Core SQL의 특별한 점을 꼽자면, 무려 Lambda 함수를 실행할 수 있는 Function까지 지원해 원하는 대로 데이터 가공이 가능합니다.&lt;/p&gt;

&lt;p&gt;이렇게 원하는 대로 가공을 마쳤다면, 이 데이터를 다른 데이터 시스템으로 전달하기 위해 여러 개의 작업을 설정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/iot-pipeline-2/worker-list.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;작업에는 미리 정의된 약 20개의 템플릿이 있으며, HTTPS 엔드포인트로도 전송할 수 있는 작업까지 준비되어 있어 원하는 대로 커스텀이 가능합니다. 이제 Kafka에 메시지를 전송할 수 있도록 작업을 추가해 보겠습니다.&lt;/p&gt;

&lt;p&gt;Apache Kafka 클러스터에 메시지 전송을 선택한 후 구성을 누르면, Kafka의 구성 정보를 입력하여 세팅할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/iot-pipeline-2/create-kafka-sink-worker.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 기본적인 Kafka 정보(Kafka 엔드포인트, SASL 구성 등)를 설정해 주세요.
Kafka에서 어떤 토픽에 메시지를 저장할 것인지 토픽 이름을 지정해야 합니다. 저희는 여기서 하나의 토픽에만 메시지를 전달하는 것이 아니라, 차량에서 수집된 정보의 종류에 따라 다른 토픽에 메시지를 전달하고 싶었습니다. 이런 처리를 위해서는 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/iot/latest/developerguide/iot-substitution-templates.html&quot;&gt;대체 템플릿&lt;/a&gt;을 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;대체 템플릿은 치환자라고 생각하시면 됩니다. IoT SQL 레퍼런스에서 지원하는 SELECT 절, WHERE 절 또는 Function을 사용할 수 있습니다. 쏘카 단말에서 보고하는 정보 중에는 해당 정보의 종류를 나타내는 타입이 존재합니다. 이 타입 별로 토픽을 분리하기 위해, 토픽 이름을 &lt;code class=&quot;highlighter-rouge&quot;&gt;message-${type}&lt;/code&gt; 으로 지정하였습니다. 이렇게 설정하면 log 타입의 메시지는 &lt;code class=&quot;highlighter-rouge&quot;&gt;message-log&lt;/code&gt;에, boot 타입의 메시지는 &lt;code class=&quot;highlighter-rouge&quot;&gt;message-boot&lt;/code&gt;에 저장하게 됩니다. 토픽이 자동 생성되는 옵션을 켜지 않으신 경우 꼭 미리 각 type에 대한 토픽을 먼저 생성하셔야 한다는 점 잊지 말아 주세요!&lt;/p&gt;

&lt;p&gt;다음은 파티션 설정입니다. 파티션은 파티션 번호를 직접 지정할 수도 있고, 지정하지 않으면 Kafka의 &lt;code class=&quot;highlighter-rouge&quot;&gt;DefaultPartitioner&lt;/code&gt;에 따라 파티션이 선택되어 메시지가 분배되게 됩니다. 여기에서 카프카의 중요한 특징을 하나 알고 가셔야 하는데, 파티션이 2개 이상인 토픽 내 메시지는 시간 순서가 지켜지지 않는다는 점입니다. 다만 파티션 내에서는 시간 순서가 지켜집니다. 쏘카에서는 각각의 프로젝트에서 실시간으로 데이터를 사용하게 될 때, 최소한 단말기 별로라도 메시지의 시간 순서가 꼭 지켜져야 합니다. 같은 단말의 메시지들이 다른 파티션에 저장되어 시간 순서대로 메시지를 사용할 수 없다면 실시간 처리가 사실상 불가능하게 됩니다. 대체 템플릿을 이용하여 메시지의 Key를 단말 번호인 &lt;code class=&quot;highlighter-rouge&quot;&gt;${device_no}&lt;/code&gt;로 지정하여 같은 단말의 메시지는 같은 파티션에 생성될 수 있도록 설정하여 이와 같은 문제를 해결할 수 있었습니다.&lt;/p&gt;

&lt;p&gt;(참고로, Kafka의 &lt;code class=&quot;highlighter-rouge&quot;&gt;DefaultPartitioner&lt;/code&gt;는 Key 값이 Null인 경우 해당 토픽의 파티션에 Round Robin 방식으로 분배하며, Key 값이 Null이 아닌 경우 Key 값을 해시화하여 파티션을 선택해 분배합니다)&lt;/p&gt;

&lt;p&gt;이렇게 메시지를 IoT Core에서 Kafka 토픽으로 무사히 전달했습니다!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/iot-pipeline-2/pipeline-next-msk.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;텔레매틱스-서버의-메시지-생성&quot;&gt;텔레매틱스 서버의 메시지 생성&lt;/h4&gt;
&lt;p&gt;기존에 차량과 통신할 때에는 총 두 채널로 통신했습니다. 명령 전달은 MQTT로 하고, 명령에 대한 응답 보고 혹은 상태 보고들을 텔레매틱스 서버로 HTTPS 방식의 보고를 하고 있었습니다. 이때, 신규 STS 단말기의 데이터 형태와 구형 단말기(CSA 단말기)의 형태가 달라 데이터를 호환시켜주는 모듈을 거쳐 동일하게 데이터가 쏘카 데이터베이스에 적재될 수 있도록 하는 일련의 과정들을 거칩니다.&lt;/p&gt;

&lt;p&gt;텔레매틱스 서버가 AWS IoT Core로 전환이 된다면, HTTPS로 텔레매틱스 서버에 상태 데이터를 전달하고 쏘카 데이터베이스에 적재되는 일련의 과정들이 생략됩니다. 기존의 연구나 분석에 사용하고 있던 데이터의 형태가 달라질 수 있기 때문에 기존에 보내고 있는 데이터의 형태와 호환성을 잘 가져갈 수 있도록 하는 것을 우선적인 목표로 잡았습니다.&lt;/p&gt;

&lt;p&gt;첫 번째로, 텔레매틱스 서버로 차량이 상태를 보고 하게 되면, 차량의 정보와 상태가 담긴 데이터가 Kinesis와 Kafka로 동시에 보내도록 작업을 했습니다. Kafka는 데이터를 전송할 때 여러 개의 토픽으로 나누어 데이터를 전송할 수 있습니다. 그 기능을 활용해 차량에서 올라오는 데이터들을 GPS, Kinematic, ADAS와 차량 주기 보고 데이터 등 각각 다른 토픽에 전송했습니다. 이로써 차량 데이터가 쏘카 데이터베이스에 저장됨은 물론, 프로젝트별로 데이터를 가져갈 때 실시간 데이터를 원하는 정보만, 원하는 토픽만을 가져와서 쉽게 처리할 수 있게 되었습니다.&lt;/p&gt;

&lt;p&gt;Kafka로 데이터를 보내기 위해 작업하는 도중, 서버 앞단의 트래픽을 보조하기 위해 사용한 uWSGI 모듈과 Python에서 Kafka를 사용할 수 있게 해 주는 kafka-python 모듈 간에 서로 충돌이 생겨서 첫 테스트에는 많은 어려움을 겪었습니다. 결국 uWSGI을 gunicorn으로 대체하고, Kafka 라이브러리도 kafka-python 대신 AWS가 제공하는 라이브러리인 boto3로 대체했습니다.&lt;/p&gt;

&lt;p&gt;두 번째로, IoT Core에서 전송된 데이터를 판별하여 데이터베이스에 적재할 수 있도록 고민이 필요했습니다. 단말기가 IoT Core로 보고하고 데이터가 바로 Kafka로 전송이 된다면, 데이터베이스에 데이터를 저장해 주는 역할을 하는 텔레매틱스 서버를 거치지 않기 때문에 차량 정보에 대해 저장이 어렵게 됩니다. 이를 위해 AWS IoT Core에 Rule을 추가해 주어 IoT Core의 데이터가 바로 Kafka로 전송되지 않고, 텔레매틱스 서버를 한번 거쳐서 Kafka로 전송할 수 있도록 해주었습니다. 텔레매틱스 서버에서 IoT Core에 대한 새로운 엔드포인트를 만들고, 해당하는 엔드포인트에서 데이터를 받아온 후 판별하여 Kafka 토픽별로 전송했습니다.&lt;/p&gt;

&lt;p&gt;IoT Core를 도입하면서 텔레매틱스 서버의 역할을 점차 줄여나가고, 결국에는 텔레매틱스 서버의 역할을 Kakfa와 연결된 Consumer 들에서 처리할 수 있도록 기능들을 점차 옮기려고 합니다. 현재는 여러 차량들을 놓고 테스트해 보고 있습니다. IoT Core를 적용 한 차량이 기존 차량과 동일하게 큰 어려움 없이 차량 데이터를 보내주고 있습니다. 아직은 초기지만, 많은 차량들이 점차 업데이트가 되어서 IoT Core로 데이터를 보낼 수 있게 되는 날이 벌써 기대가 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/iot-pipeline-2/pipeline-prev-msk.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;consumer&quot;&gt;Consumer&lt;/h3&gt;
&lt;p&gt;이제 수집된 차량 정보가 Kafka 토픽에 안전하게 저장되어 있습니다. 이 데이터를 적재적소에 가져다가 활용하면 됩니다.
하지만 카프카는 영구 저장소가 아니라서, 우리가 설정한 값에 따르면 2일 후에 사라지게 됩니다. 먼저 이를 더 오랫동안 보관하고 활용할 수 있는 공간으로 먼저 저장해야 합니다. 이런 툴을 일일이 개발해야 할까요?&lt;/p&gt;

&lt;h4 id=&quot;kafka-connect&quot;&gt;Kafka Connect&lt;/h4&gt;
&lt;p&gt;물론 자신 있는 언어의 Kafka 클라이언트를 이용하여 Consumer를 한 땀 한 땀 개발할 수도 있겠지만, Kafka 생태계에서는 Kafka와 다른 데이터 시스템 사이를 쉽고 믿을 수 있게 이어줄 수 있는 Kafka Connect를 제공합니다.&lt;/p&gt;

&lt;p&gt;많은 회사와 개발자들이 사용하는 RDBMS부터 NoSQL, S3 같은 클라우드 저장소, Elasticsearch 등 수많은 데이터 시스템과 카프카를 이어주는 Connector를 공식적으로 제공하고 있으며, 커뮤니티에서 만든 비공식의 Connector들도 활발하게 만들어져 있어 Kafka Connect 클러스터만 구축한다면 Connector들을 바로 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;다른 데이터 시스템에서 Kafka로 데이터를 가져오는 커넥터를 Source Connector라 하고, Kafka에서 다른 데이터 시스템으로 데이터를 적재하는 커넥터를 Sink Connector라고 합니다. 우리는 Kafka에 있는 데이터를 소비하는 Consumer를 만드는 과정이므로 Sink Connector를 설정해보겠습니다.&lt;/p&gt;

&lt;p&gt;쏘카의 단말 데이터는 오래 저장하고 다시 여러 가지 용도로 사용할 수 있도록 1차적으로 S3에 저장하고 있으며, 최신 데이터는 바로 분석과 연구에 사용할 수 있도록 Elasticsearch에 적재해 활용하고 있습니다.&lt;/p&gt;

&lt;p&gt;Kafka Connect 클러스터는 구축되어 있다고 가정하고, 바로 Sink Connector를 설정해보겠습니다. Kafka Connect에서는 Connector를 실행시킬 수 있는 REST API를 제공합니다. S3와 Elasticsearch Sink Connector를 세팅하면서 자세히 알아보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/iot-pipeline-2/pipeline-next-kafkaconnect.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;s3-sink-connector&quot;&gt;S3 Sink Connector&lt;/h5&gt;
&lt;p&gt;Confluent에서 공식으로 제공하는 S3 Sink Connector입니다.
다음 요청을 통해 해당 커넥터를 이용한 Worker를 생성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;Endpoint : &lt;code class=&quot;highlighter-rouge&quot;&gt;POST ${카프카_커넥트_호스트}/connectors&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;name&quot;:&quot;s3-sink-worker&quot;,
    &quot;config&quot;: {
        // 사용하려는 커넥터의 클래스 이름
        &quot;connector.class&quot;: &quot;io.confluent.connect.s3.S3SinkConnector&quot;,

        // S3가 위치한 리전
        &quot;s3.region&quot;: &quot;ap-northeast-2&quot;,

        &quot;partition.duration.ms&quot;: &quot;180000&quot;,
        
        // 여기서 지정한 수만큼 메시지가 쌓이면 S3에 파일로 저장합니다.
        &quot;flush.size&quot;: &quot;20000&quot;,
        
        &quot;schema.compatibility&quot;: &quot;NONE&quot;,
        
        // 메시지를 가져오려는 카프카의 토픽 이름을 지정합니다. 콤마를 사용해 여러 토픽을 가져올 수 있습니다.
        &quot;topics&quot;: &quot;토픽 이름&quot;,
        
        // 하나의 파일이 가질 최대 용량을 지정합니다.
        &quot;s3.part.size&quot;: &quot;5242880&quot;,
        
        // 타임존을 지정합니다.
        &quot;timezone&quot;: &quot;Asia/Seoul&quot;,
        
        // 로케일을 지정합니다.
        &quot;locale&quot;: &quot;ko_KR&quot;,
        
        // 압축 방식을 지정합니다. none 또는 gzip을 사용할 수 있습니다.
        &quot;s3.compression.type&quot;: &quot;gzip&quot;,
        
        // 데이터 포맷을 지정힙니다. JSON 타입이므로 JsonFormat을 사용합니다.
        &quot;format.class&quot;: &quot;io.confluent.connect.s3.format.json.JsonFormat&quot;,
        
        // 메시지를 어떻게 파티셔닝할지 설정합니다. 여기서는 TimeBasedPartitioner를 사용하여 날짜 기준으로 S3에 저장되는 폴더를 분리합니다.
        &quot;partitioner.class&quot;: &quot;io.confluent.connect.storage.partitioner.TimeBasedPartitioner&quot;,
        
        // S3Storage로 지정해주시면 됩니다.
        &quot;storage.class&quot;: &quot;io.confluent.connect.s3.storage.S3Storage&quot;,
        
        // 저장될 S3의 버킷 이름입니다.
        &quot;s3.bucket.name&quot;: &quot;S3 버킷 이름&quot;,
        
        // 얼마나 주기적으로 S3에 파일을 저장할지 설정합니다. flush.size에서 설정한 메시지 수에 도달하지 않아도 해당 주기가 되면 S3에 파일을 쓰게 됩니다.
        &quot;rotate.schedule.interval.ms&quot;: &quot;180000&quot;,
        
        // 파일이 저장될 위치를 설정합니다. 시간 기반의 파티셔닝을 통해 시간별로 폴더가 나눠지도록 설정했습니다.
        &quot;path.format&quot;: &quot;YYYY/MM/dd/HH&quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Worker를 생성한 후, 다음 REST API를 통해 Worker가 제대로 동작하는지 확인하실 수 있습니다.&lt;/p&gt;

&lt;p&gt;Endpoint : &lt;code class=&quot;highlighter-rouge&quot;&gt;${카프카_커넥트_호스트}/connectors?expand=info&amp;amp;expand=status&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;s3-sink-worker&quot;: {
    &quot;status&quot;: {
      &quot;name&quot;: &quot;s3-sink-worker&quot;,
      &quot;connector&quot;: {
        &quot;state&quot;: &quot;RUNNING&quot;,
        &quot;worker_id&quot;: &quot;Worker 1&quot;
      },
      &quot;tasks&quot;: [
        {
          &quot;id&quot;: 0,
          &quot;state&quot;: &quot;RUNNING&quot;,
          &quot;worker_id&quot;: &quot;Worker 1&quot;
        },
        {
          &quot;id&quot;: 1,
          &quot;state&quot;: &quot;RUNNING&quot;,
          &quot;worker_id&quot;: &quot;Worker 2&quot;
        },
        {
          &quot;id&quot;: 2,
          &quot;state&quot;: &quot;RUNNING&quot;,
          &quot;worker_id&quot;: &quot;Worker 3&quot;
        }
      ],
      &quot;type&quot;: &quot;sink&quot;
    },
    &quot;info&quot;: {
      &quot;name&quot;: &quot;s3-sink-worker&quot;,
      &quot;config&quot;: {
        &quot;connector.class&quot;: &quot;io.confluent.connect.s3.S3SinkConnector&quot;,
        &quot;s3.region&quot;: &quot;ap-northeast-2&quot;,
        &quot;partition.duration.ms&quot;: &quot;180000&quot;,
        &quot;flush.size&quot;: &quot;20000&quot;,
        &quot;schema.compatibility&quot;: &quot;NONE&quot;,
        &quot;topics&quot;: &quot;토픽 이름&quot;,
        &quot;s3.part.size&quot;: &quot;5242880&quot;,
        &quot;timezone&quot;: &quot;Asia/Seoul&quot;,
        &quot;locale&quot;: &quot;ko_KR&quot;,
        &quot;s3.compression.type&quot;: &quot;gzip&quot;,
        &quot;format.class&quot;: &quot;io.confluent.connect.s3.format.json.JsonFormat&quot;,
        &quot;partitioner.class&quot;: &quot;io.confluent.connect.storage.partitioner.TimeBasedPartitioner&quot;,
        &quot;storage.class&quot;: &quot;io.confluent.connect.s3.storage.S3Storage&quot;,
        &quot;s3.bucket.name&quot;: &quot;S3 버킷 이름&quot;,
        &quot;rotate.schedule.interval.ms&quot;: &quot;180000&quot;,
        &quot;path.format&quot;: &quot;YYYY/MM/dd/HH&quot;
      },
      &quot;tasks&quot;: [
        {
          &quot;connector&quot;: &quot;s3-sink-worker&quot;,
          &quot;task&quot;: 0
        },
        {
          &quot;connector&quot;: &quot;s3-sink-worker&quot;,
          &quot;task&quot;: 1
        },
        {
          &quot;connector&quot;: &quot;s3-sink-worker&quot;,
          &quot;task&quot;: 2
        }
      ],
      &quot;type&quot;: &quot;sink&quot;
    }
  },
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다른 문제가 없다면 수 분 내로 S3의 파일로 메시지가 잘 적재되는 모습을 확인하실 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/iot-pipeline-2/result-s3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Kafka Connect의 Worker들은 동작하면서 필요한 메타데이터를 Kafka에 별도의 토픽으로 저장합니다. Worker는 자신의 업무 프로세스를 기억하기 위해 순차적으로 토픽의 파티션에서 데이터를 읽어가면서 책갈피를 꽂아둡니다. 이 책갈피를 Offset이라고 합니다. Kafka Connect는 프로세스가 죽어서 Worker가 재시작되는 상황이 발생해도 이 메타데이터를 다시 읽어와 책갈피를 꽂은 부분에서부터 다시 데이터를 읽어가도록 설계되어 있습니다.&lt;/p&gt;

&lt;h5 id=&quot;elasticsearch-sink-connector&quot;&gt;Elasticsearch Sink Connector&lt;/h5&gt;
&lt;p&gt;S3에 무사히 적재했다면, 다음은 분석과 연구를 위한 Elasticsearch에 적재해보겠습니다. Confluent에서 공식으로 제공하는 Elasticsearch Sink Connector를 사용합니다. S3 Sink Connector와 같은 방식으로 생성하는데, 다음과 같은 요청을 통해 Elasticsearch Sink Worker를 실행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;Endpoint : &lt;code class=&quot;highlighter-rouge&quot;&gt;POST ${카프카_커넥트_호스트}/connectors&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;name&quot;:&quot;es-sink-worker&quot;,
  &quot;config&quot;: {
    // 사용하려는 커넥터의 클래스 이름
    &quot;connector.class&quot;: &quot;io.confluent.connect.elasticsearch.ElasticsearchSinkConnector&quot;,
    
    // Elasticsearch7부터는 type이 사라져, _doc로 지정하면 됩니다.
    &quot;type.name&quot;: &quot;_doc&quot;,
    
    &quot;behavior.on.null.values&quot;: &quot;IGNORE&quot;,
    
    // 메시지를 가져오려는 토픽 이름
    &quot;topics&quot;: &quot;토픽 이름&quot;,
    
    // true일 때, 메시지에 문제가 있는 경우 무시합니다.
    &quot;drop.invalid.message&quot;: &quot;true&quot;,
    
    // 문제가 생긴 경우 최대 재시도 횟수를 설정합니다.
    &quot;max.retries&quot;: &quot;50&quot;,
    
    // true일 때, Elasticsearch 문서의 키로 메시지의 key를 사용하지 않고, topic+partition+offset를 사용합니다. ex) message-log+0+1
    &quot;key.ignore&quot;: &quot;true&quot;,
    
    // Elasticsearch 동시 요청 수를 제한합니다. retry.backoff.ms: 요청 실패 후 재시도까지 기다릴 시간을 설정합니다. 다음 재시도할 때엔 이전 재시도 대기 시간보다 2배 더 기다립니다.
    &quot;max.in.flight.requests&quot;: &quot;20&quot;,
    
    &quot;retry.backoff.ms&quot;: &quot;2000&quot;,
    
    // 사용하려는 Elasticsearch의 Endpoint
    &quot;connection.url&quot;: &quot;ELASTICSEARCH_ENDPOINT&quot;,
    
    // Elasticsearch 서버와의 Read Timeout을 설정합니다.
    &quot;read.timeout.ms&quot;: &quot;60000&quot;,
    
    // 주어진 시간만큼 데이터가 쌓이기를 기다린 다음, Bulk Request로 처리하여 효율성을 높입니다. connection.compression: Elasticsearch 서버와 통신 시에 gzip 압축을 사용할지 여부를 선택합니다.
    &quot;linger.ms&quot;: &quot;1000&quot;,
    &quot;connection.compression&quot;: &quot;true&quot;,
    
    // 메시지가 원하는 만큼 쌓이지 않았더라도, 해당 주기가 되면 Elasticsearch로 메시지를 전송합니다.
    &quot;flush.timeout.ms&quot;: &quot;60000&quot;,
    
    // 배치로 처리할 메시지의 수
    &quot;batch.size&quot;: &quot;2000&quot;,
    
    // 최대 버퍼 될 레코드의 수, 태스크 당 메모리 사용량 제한을 위해 사용합니다.
    &quot;max.buffered.records&quot;: &quot;40000&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;S3 커넥터 설정할 때와 마찬가지로 REST API를 통해 Worker가 정상적으로 동작하고 있는지를 확인해 주세요. 잠시만 기다리면 Elasticsearch에도 메시지가 잘 적재되는 것을 확인하실 수 있습니다!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/iot-pipeline-2/result-es.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Elasticsearch Sink Connector에는 알려진 버그가 있습니다. 쏘카에서는 최신의 단말 데이터만 Elasticsearch에서 활용하고 있어서 일자별로 인덱스를 생성하고, 며칠 뒤 오래된 인덱스를 삭제하는 형식을 취하고 있습니다. Elasticsearch Sink Connector는 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimebasedPartitioner&lt;/code&gt;를 사용하면 Offset을 제대로 기록하지 못해 설정을 변경하는 등의 이유로 Worker를 재시작할 때마다 토픽에 있는 모든 데이터를 처음부터 다시 읽는 버그가 있습니다.&lt;/p&gt;

&lt;p&gt;이를 해결하기 위해, Elasticsearch Sink Connector를 사용할 때에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimeBasedPartitioner&lt;/code&gt;를 사용하지 않고 Elasticsearch의 Index를 고정하여 사용하기로 했습니다. Elasticsearch에서 Index를 생성할 때 Write Index와 Rollover를 사용하여 Index가 일자별로 자동으로 생성되도록 데이터가 저장되도록 설정해 이 문제를 해결할 수 있었습니다.&lt;/p&gt;

&lt;h3 id=&quot;단말-차량-converter&quot;&gt;단말-차량 Converter&lt;/h3&gt;
&lt;p&gt;“단말-차량 Converter”는 모비딕 팀에서 최근에 시작한 프로젝트로, Kafka의 도입과 비슷한 시기에 시작한 프로젝트입니다. Kafka에서 수집하는 차량의 데이터는 거의 실시간으로 파악할 수 있기 때문에 이 데이터의 활용도가 무척 높을 거라고 생각했습니다.&lt;/p&gt;

&lt;p&gt;차량 데이터는 차량 단말기 번호를 기준으로 수집되는데, “단말-차량 Converter”는 이 데이터를 바로 사용할 수 있도록, 데이터를 변형하여 Kafka로 다시 흘려보내주는 역할을 합니다. 즉, “단말-차량 Converter”는 확장성이 높은 첫 Consumer이자 동시에 데이터를 제공해 주는 Producer 역할을 동시에 하게 됩니다. 이렇게 수집된 데이터는 원하는 곳에서, 필요한 만큼 실시간으로 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;“단말-차량 Converter”의 기능을 구체적으로 말씀드리면, 단말기에서 올라온 정보를 기반으로 차량 정보를 매칭해 주고, 해당하는 데이터가 어떤 차량의 어떤 상태인지 파악할 수 있도록 데이터 조립을 해 줍니다. 차량의 정보를 데이터베이스에서 계속 가져온다면 너무 비효율적이기 때문에, 임시로 저장해 놓은 캐싱 된 데이터를 사용하고, 일정 주기로 데이터를 새로 받아오는 일들을 하고 있습니다.&lt;/p&gt;

&lt;p&gt;이렇게 조립한 데이터들이 앞으로 필요한 프로젝트들에 잘 활용될거라 기대하고 있습니다. 또한 어떤 프로젝트든 쉽게 데이터를 사용할 수 있게 데이터를 좀 더 유연하게 설계해나가고 싶습니다. 
추가적으로 필요한 연산 작업이라든지, 적재 작업들도 “단말-차량 Converter”를 통해 만들어나갈 수 있을 것 같고, 최근 뜨고 있는 스트림 처리 프레임워크인 Flink를 써 볼 수 있지 않을까 하는 기대감도 가지고 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;단말-파이프라인-모니터링-&quot;&gt;단말 파이프라인 모니터링 &lt;a name=&quot;monitoring&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;구축한 단말 파이프라인이 문제 없이 원활히 흘러가도록 하려면 모니터링의 역할도 아주 중요합니다.&lt;/p&gt;

&lt;p&gt;쏘카에는 여러 모니터링 시스템이 구축되어 있는데, 그중 Grafana를 통해 단말 파이프라인 모니터링 대시보드를 구축했습니다. 데이터 소스로 CloudWatch가 이미 연동되어 있어, MSK의 중요한 메트릭으로 대시보드를 꾸리기만 하면 완성입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/iot-pipeline-2/monitoring.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;운영 중인 Grafana 대시보드&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;CPU, Disk 사용량, 네트워크 In/Out, Elasticsearch의 스토리지 사용량을 기본적으로 모니터링하고 있으며, 각 Consumer의 OffsetLag까지 추가적으로 모니터링하여 각 Consumer에서 데이터를 가져가는 데에 지연이 발생하지 않는지를 모니터링하고 있습니다.&lt;/p&gt;

&lt;p&gt;OffsetLag가 무엇일까요? 각 Consumer에서는 토픽의 파티션 별로 메시지를 어디까지 가져갔는지를 기록하는 책갈피를 남겨놓는다고 했는데, 바로 Offset입니다. 파티션의 가장 마지막 메시지와 Offset의 차이가 OffsetLag입니다. OffsetLag가 줄어들지 않고 지속적으로 증가하는 경우 해당 Consumer가 제대로 동작하지 않는다고 판단할 수 있고, 이를 통하여 Consumer의 장애를 인지하고 장애에 대한 조치를 수행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;(참고로 OffsetLag는 MSK의 고급 모니터링 옵션을 사용해야 모니터링이 가능합니다.)&lt;/p&gt;

&lt;p&gt;이렇게 단말 데이터 파이프라인을 모니터링할 수 있는 대시보드가 완성되었습니다! 필요한 메트릭에 알림을 만들어, 임계치에 도달한 경우 Slack 또는 Opsgenie를 통해 알림을 받아 장애를 인지하고, 조치하고 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;마치며-&quot;&gt;마치며 &lt;a name=&quot;wrap-up&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;여전히 신규 데이터 파이프라인 개발은 현재진행형입니다. Schema Registry를 이용해 단말 데이터에 스키마를 입히고, 사내 많은 분들이 활발하게 사용 중인 BigQuery에 스트리밍으로 단말 데이터를 적재해야 하는 등 해야 할 일들이 많이 있습니다.&lt;br /&gt;
하지만 첫 술에 배부를 수 없듯이, 이번 목표는 토대를 단단하게 구축하여 어떤 서비스나 프로젝트에 찰떡처럼 붙을 수 있는 파이프라인을 만드는 것이었고, 결과적으로 짧은 시간 안에 소기의 성과를 달성할 수 있었습니다.&lt;/p&gt;

&lt;p&gt;이번에 개선한 신규 단말 파이프라인을 토대로 전사에서 단말 데이터를 더욱 잘 활용할 수 있도록 하고, 더 나아가 유저에게 더 나은 쏘카 서비스 경험을 선물할 수 있도록 앞으로도 모비딕 팀이 계속 노력하겠습니다.&lt;/p&gt;</content><author><name>bada, oliver</name></author><category term="mobility" /><category term="iot" /><category term="data" /><category term="data-engineering" /><summary type="html">Photo by SELİM ARDA ERYILMAZ on Unsplash</summary></entry><entry><title type="html">Android Studio 플러그인으로 코드 자동 리팩토링하기</title><link href="https://tech.socarcorp.kr/dev/2022/02/03/refactoring-with-intellij-plugin.html" rel="alternate" type="text/html" title="Android Studio 플러그인으로 코드 자동 리팩토링하기" /><published>2022-02-03T08:00:00+00:00</published><updated>2022-02-03T08:00:00+00:00</updated><id>https://tech.socarcorp.kr/dev/2022/02/03/refactoring-with-intellij-plugin</id><content type="html" xml:base="https://tech.socarcorp.kr/dev/2022/02/03/refactoring-with-intellij-plugin.html">&lt;p&gt;안녕하세요, 쏘카 안드로이드 팀의 지안입니다.&lt;/p&gt;

&lt;p&gt;리팩토링 작업은 한두 개의 함수를 개선하는 것으로 충분한 때도 있지만, 때로는 여러 개의 파일을 전체적으로 고치고 나서야 끝이 나는 경우도 있습니다.
복잡한 로직이 아닌 단순한 코드 수정 작업이라 생각하여 가볍게 시작하더라도, 리팩토링의 대상이 되는 코드가 곳곳에 사용되고 있다면 처음에 생각한 예상 시간보다 많은 시간이 걸려 난처해지는 경우도 생기곤 합니다.
또한 그 과정에서 처음에는 예상하지 못했던 특이한 케이스라던가, 수정 과정에서 실수로 빠트리는 부분, 반복되는 동일 작업으로 인한 집중력 하락 등으로 인해 일정이 밀리다 보면 ‘리팩토링을 시작하지 말았어야 했나?’ 하는 생각이 드는 경우도 있습니다.&lt;/p&gt;

&lt;p&gt;저희 안드로이드 팀에서도 몇 개월 전, 광범위한 코드에 대한 리팩토링을 수행한 경험이 있습니다.
코드 변환의 규칙은 단순했지만, 수십에서 수백 개 파일에 걸친 변경사항을 하나하나 고치려고 하다 보니 마냥 쉽지만은 않았습니다.
그리고 자칫 길어질 뻔했던 그 반복적인 작업은 IntelliJ Platform Plugin을 통해서 훨씬 수월해질 수 있었습니다.&lt;/p&gt;

&lt;p&gt;당시에 리팩토링 작업을 하며 내부 세미나를 통해 발표했던 내용을, 연말연시를 맞이하여 이 글을 통해 다시금 정리해서 공유해 보고자 합니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;리팩토링을-마음먹게-된-계기&quot;&gt;리팩토링을 마음먹게 된 계기&lt;/h2&gt;
&lt;h3 id=&quot;view-binding으로의-전환&quot;&gt;View Binding으로의 전환&lt;/h3&gt;
&lt;p&gt;안드로이드에서 View에 접근하는 방식은 &lt;a href=&quot;https://medium.com/mobile-app-development-publication/how-android-access-view-item-the-past-to-the-future-bb003ae84527&quot;&gt;계속해서 바뀌어&lt;/a&gt; 왔습니다.
이러한 변화 중에서 현재 가장 이슈가 되고 있는 것은 아무래도 Jetpack Compose의 &lt;a href=&quot;https://android-developers.googleblog.com/2021/07/jetpack-compose-announcement.html&quot;&gt;정식 출시&lt;/a&gt;겠지만, 이 글은 그보다 약간 이전에 있었던 사건에 관한 이야기입니다.&lt;/p&gt;

&lt;p&gt;2020년 말, Kotlin Synthetics 가 Kotlin Android Extensions와 함께 &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.4.20&quot;&gt;deprecated&lt;/a&gt; 되었습니다.
다행스럽게도 저희는 그 시점에 Kotlin Synthetics를 직접 사용하지 않고 &lt;a href=&quot;https://github.com/JakeWharton/butterknife&quot;&gt;ButterKnife&lt;/a&gt; 기반의 &lt;a href=&quot;https://github.com/Rajin9601/ButterKt&quot;&gt;ButterKt&lt;/a&gt;를 수정해서 활용하고 있었기 때문에 deprecation의 직접적인 영향 없이 Kotlin 버전을 업데이트할 수 있었습니다.
그러나 ButterKnife의 README 파일에도 적혀있듯이, View Binding을 사용하라는 권고는 늘 마음 한편과 기술 부채 목록에 남아있었죠.&lt;/p&gt;

&lt;p&gt;하기야 View에 대한 타입 추론도 잘해주고, 속도도 이전에 비해 빨라지고, View에 대한 구조적인 접근도 가능한 View Binding을 사용하는 것에 딱히 나쁜 점은 없었습니다.
더군다나 이렇게 &lt;a href=&quot;https://developer.android.com/topic/libraries/view-binding/migration&quot;&gt;Migration 가이드&lt;/a&gt;도 제공하고 있고요.&lt;/p&gt;

&lt;p&gt;가이드를 보면서 저희 코드를 기준으로 얼핏 생각해 보았을 때는 기존에 사용하던 아래와 같은 코드를&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BaseActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;maybe_different_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TextView&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bindView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;declared_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;someFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;maybe_different_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;value&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이렇게 아래처럼 변경해 주기만 하면 될 것으로 보입니다.&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ChangedActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BaseActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;changedFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;declaredId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;value&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러나 이렇게 가벼운 마음으로 작업을 하다 보면 이어지는 절에서 이야기할 번거로운 부분들이 보이기 시작합니다.
혹시 이런 번거로운 부분들을 해결해 줄 더 좋은 Migration 방법이 제공될까 싶어서 기다리다 보니, 어느새 이 작업의 우선순위는 다른 Feature들에 의해 계속해서 밀리게 되었습니다.&lt;/p&gt;

&lt;p&gt;하지만 역설적이게도 우선순위가 높은 Feature 화면의 개발 중에는 여전히 View의 타입이나 XML ID 매칭으로 인한 문제가 종종 발생해서 시간을 소비하곤 했습니다.
결국 이러한 문제로 인해 개발 시간이 불필요하게 늘어나고 있다는 의견에 도달하자 View Binding으로 전환하는 리팩토링을 본격적으로 시작하게 되었습니다.
다만, 무작정 작업에 돌입하기보다는 효율적인 방법에 대해서 생각해 볼 필요가 있었죠.&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;리팩토링-검토&quot;&gt;리팩토링 검토&lt;/h2&gt;
&lt;h3 id=&quot;view-binding-전환에-필요한-것&quot;&gt;View Binding 전환에 필요한 것&lt;/h3&gt;
&lt;p&gt;위에서도 언급했다시피 View Binding으로 리팩토링하는 작업을 위해 요구사항을 정리하다 보면 처음에 가졌던 생각보다 번거로운 지점이 보여서 멈칫멈칫하게 되는 부분들이 있었습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;by bindView&lt;/code&gt; Delegate를 사용하는 변수들을 쓰고 있는 모든 Usage에 대해 이름 변경이 필요하다.&lt;/li&gt;
  &lt;li&gt;기존 방식과는 달리 앞에 &lt;code class=&quot;highlighter-rouge&quot;&gt;binding.&lt;/code&gt;을 붙여서 접근하도록 해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 요구사항만 놓고 보면 단순하게 Regex를 사용해서 치환해도 어떻게든 작업이 가능할 것 같다는 생각이 듭니다.&lt;/p&gt;

&lt;p&gt;그러나 요구사항 검토를 계속해서 진행하다가 아래와 같이 조금 더 까다로운 항목을 발견하게 되면 골치가 아파지기 시작합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Kotlin 파일에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;bindView&lt;/code&gt;로 사용하고 있는 변수명의 케이스를 변경(&lt;code class=&quot;highlighter-rouge&quot;&gt;snake_case&lt;/code&gt; → &lt;code class=&quot;highlighter-rouge&quot;&gt;lowerCamelCase&lt;/code&gt;)해줘야 한다.&lt;/li&gt;
  &lt;li&gt;만약 XML에 있는 ID(&lt;code class=&quot;highlighter-rouge&quot;&gt;R.id.~&lt;/code&gt;)와 다른 변수명을 사용하고 있다면 XML의 ID를 사용하도록 변경해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 시점에서 Regex를 이용한 ‘단순’ 치환은 어렵겠다는 생각이 듭니다.
그래도 Android Studio를 사용하고 있으니 IDE의 기능을 빌어서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Refactoring → Rename&lt;/code&gt; 기능을 시도해 볼 수는 있을 것 같습니다.
변수 하나를 변경하는데 타이핑을 빠르게 하면 5~10초 정도 걸리는 것 같으니 나쁘지는 않아 보입니다.
하지만…&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Activity, Fragment, Custom View를 포함한 뷰 코드 파일들이 백 개가 넘고, 각각의 파일에는 XML ID와 연결되어 있는 변수가 수십 개 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이렇게 되면 하나하나 타이핑해가면서 수동으로 수정하기에는 부담스러운 분량입니다.
수정하는 과정에서 행여나 누락되는 곳이나 실수하는 곳이 있지는 않을지 걱정도 되고요.
단순한 작업이다 싶어서 시작한 일인데 이렇게까지 반복적인 작업을 오랜 시간에 걸쳐서 신경 써가며 작업해야 할까 싶은 생각이 듭니다.&lt;/p&gt;

&lt;p&gt;그렇게 해서 자동으로 Kotlin 코드를 파싱 하여 수정하는 방법들까지도 검토해 보게 되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;사용해-볼-만한-방법들&quot;&gt;사용해 볼 만한 방법들&lt;/h3&gt;
&lt;p&gt;그런 생각을 거쳐서 아래에 있는 다섯 가지 정도의 방법을 떠올리고 간단하게 비교를 진행했습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Android Studio의 Rename 기능을 변수 하나하나에 적용해서 바꾸기&lt;/li&gt;
  &lt;li&gt;Regex를 사용해서 찾아 바꾸기&lt;/li&gt;
  &lt;li&gt;Kotlin Compiler의 &lt;a href=&quot;https://github.com/JetBrains/kotlin/tree/master/compiler/psi/src/org/jetbrains/kotlin/parsing&quot;&gt;Parsing&lt;/a&gt;을 사용하기&lt;/li&gt;
  &lt;li&gt;LSP와 &lt;a href=&quot;https://github.com/fwcd/kotlin-language-server&quot;&gt;비공식 Kotlin Language Server&lt;/a&gt;의 &lt;a href=&quot;https://github.com/fwcd/kotlin-language-server/pull/319&quot;&gt;Rename&lt;/a&gt;을 사용하기&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://plugins.jetbrains.com/docs/intellij/welcome.html&quot;&gt;IntelliJ Platform Plugin&lt;/a&gt;을 만들어서 동작시키기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 중에서 Android Studio의 IDE 기능을 써서 Renaming 하는 방식은 신뢰도가 높고 추가적인 개발이 필요 없지만, 각각의 변수들을 하나하나 수정해야 하므로 작업에 걸리는 시간이 길어진다는 단점이 있었습니다.&lt;/p&gt;

&lt;p&gt;그리고 정규 표현식으로 찾아 바꾸는 작업은 여러 변수나 파일들을 한꺼번에 고칠 수는 있었지만, Reference(Usage)를 명확하게 구분해 내기가 어렵고 정규 표현식을 작성하는 것에도 시간이 많이 소요된다는 문제가 있었습니다.&lt;/p&gt;

&lt;p&gt;Kotlin Compiler를 써서 Parsing 하거나, LSP를 사용해서 수정하는 것은 해당 기능을 개발하기 위해 필요한 배경지식들이 과도하게 많이 필요했습니다.
전체 작업에 드는 시간을 고려하면 변수를 하나하나 바꾸는 데 걸리는 시간이 오히려 비슷하거나 빠를 수도 있겠다는 판단도 들었습니다.
또한 Kotlin Language Server는 아직 &lt;a href=&quot;https://discuss.kotlinlang.org/t/any-plan-for-supporting-language-server-protocol/2471&quot;&gt;공식적으로 제공되지 않고 있으며&lt;/a&gt;, 비공식 Language Server에서는 &lt;a href=&quot;https://github.com/fwcd/kotlin-language-server/pull/319&quot;&gt;Rename 기능에 문제&lt;/a&gt;가 있다는 이야기도 있어서 섣불리 시도해 보기도 어려웠고요.&lt;/p&gt;

&lt;p&gt;반면에 IntelliJ Platform Plugin은 기존에 IDE에서도 사용해왔던 기능들을 그대로 사용할 테니 Reference를 제대로 찾아서 변경해 주는 안정성이 확보되어 있다고 볼 수 있었습니다.
또한 이미 다양한 기능을 가진 플러그인들이 Plugin Marketplace에 올라와 있는 것을 보면 단지 이번 리팩토링뿐만 아니라 다른 기능을 추가해 볼 수도 있을 것이라는 생각도 들었습니다.
물론 개발에 들어가는 시간이 있겠지만 Kotlin Compiler나 LSP를 다루는 것보다는 빠르게 진행할 수 있으리라고 보았습니다.&lt;/p&gt;

&lt;p&gt;앞서 이야기한 몇몇 기준점을 가지고 각각의 방식을 간략하게 비교하면 아래의 표와 같이 정리할 수 있습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;IntelliJ Rename&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Regex Replace&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Kotlin Parser&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Language Server&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;IntelliJ Plugin&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;대량 수정(자동화)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;O&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Usage 검색 기능&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;O&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;포매팅 유지&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;O&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;개발에 필요한 시간&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;없음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;보통&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;많음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;많음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;보통&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;확장성&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;낮음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;낮음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;보통&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;보통&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;높음&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이러한 비교를 바탕으로 개발 시간이 많이 필요하지 않으면서도 자동화가 가능한 IntelliJ Platform Plugin 방식을 선택했고, 이를 통해 View Binding으로의 리팩토링을 진행해 보기로 했습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;intellij-platform-plugin&quot;&gt;IntelliJ Platform Plugin&lt;/h2&gt;
&lt;p&gt;그렇다고 하더라도 자료를 찾기 어렵다면 개발 시간이 길어질 것이므로 걱정했지만, 다행스럽게도 JetBrains에서는 공식적으로 IntelliJ Platform에서 사용 가능한 &lt;a href=&quot;https://lp.jetbrains.com/gradle-intellij-plugin/&quot;&gt;플러그인&lt;/a&gt; 개발에 대한 &lt;a href=&quot;https://plugins.jetbrains.com/docs/intellij/welcome.html&quot;&gt;문서&lt;/a&gt;를 제공하고 있었습니다.
이 문서의 &lt;a href=&quot;https://plugins.jetbrains.com/docs/intellij/getting-started.html&quot;&gt;Getting Started 페이지&lt;/a&gt;에 따르면 아래와 같은 방식으로 플러그인을 개발하는 것을 권장하고 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;There are three supported workflows available for building plugins. The &lt;strong&gt;recommended workflow&lt;/strong&gt; for new projects is to use &lt;a href=&quot;https://github.com/JetBrains/intellij-platform-plugin-template&quot;&gt;GitHub Template&lt;/a&gt; or to use &lt;a href=&quot;https://github.com/JetBrains/gradle-intellij-plugin&quot;&gt;Gradle&lt;/a&gt; to create everything from scratch. The old Plugin DevKit workflow still supports existing projects.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이렇게 나열된 방식 중에서 비교적 간단하게 개발할 수 있는 방식인 &lt;a href=&quot;https://github.com/JetBrains/intellij-platform-plugin-template&quot;&gt;GitHub Template&lt;/a&gt;를 통해 그 안에 있는 예제 플러그인 코드로부터 개발을 시작했습니다.&lt;/p&gt;

&lt;h3 id=&quot;예제-플러그인-동작-확인&quot;&gt;예제 플러그인 동작 확인&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JetBrains/intellij-platform-plugin-template&quot;&gt;링크&lt;/a&gt;로부터 예제 템플릿 레포지토리를 클론 해와서 Android Studio로 열어보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Run Configurations&lt;/code&gt; 중에 &lt;code class=&quot;highlighter-rouge&quot;&gt;Run Plugin&lt;/code&gt;이라는 항목을 볼 수 있습니다.
그 항목을 선택하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Run&lt;/code&gt; 버튼을 눌러서 이를 실행시키면 예제 플러그인이 설치되어 동작할 IntelliJ Community Edition이 자동으로 다운로드되고, 그 Sandbox 인스턴스 IDE가 새로 뜨며, 그 위에서 예제 플러그인이 돌아가는 것을 확인해 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/JetBrains/intellij-platform-plugin-template/tree/v1.1.0#plugin-configuration-file&quot;&gt;설명&lt;/a&gt;에도 나와있듯이 &lt;code class=&quot;highlighter-rouge&quot;&gt;/src/main/resources/META-INF/plugin.xml&lt;/code&gt; 파일에 &lt;code class=&quot;highlighter-rouge&quot;&gt;applicationService&lt;/code&gt;로 지정된 &lt;code class=&quot;highlighter-rouge&quot;&gt;MyApplicationService.kt&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;projectService&lt;/code&gt;로 지정된 &lt;code class=&quot;highlighter-rouge&quot;&gt;MyProjectService.kt&lt;/code&gt;가 Sandbox IDE의 로드 시점에 수행되며, &lt;code class=&quot;highlighter-rouge&quot;&gt;println&lt;/code&gt;으로 출력하는 메시지가 바깥쪽 IDE의 Run 탭에 출력되는 것을 확인할 수 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/intellij-plugin/sample.png&quot; alt=&quot;기본 예제 확인&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;kotlin-코드-다루기&quot;&gt;Kotlin 코드 다루기&lt;/h3&gt;
&lt;p&gt;하지만 우리가 플러그인을 통해 최종적으로 이름 변경을 하기 위해서는 Kotlin 코드를 인식하고 분석하는 기능이 필요합니다.
기존에 Android Studio를 비롯한 IntelliJ 계열 IDE에도 Renaming 기능이 있기 때문에, 플러그인에도 관련 내용이 있으리라 판단했고, 아니나 다를까 &lt;a href=&quot;https://plugins.jetbrains.com/docs/intellij/kotlin.html#handling-kotlin-code&quot;&gt;이 문서&lt;/a&gt;에서 Kotlin 관련 내용을 찾을 수 있었습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If a plugin processes Kotlin code (e.g., providing inspections), it needs to add a dependency on the Kotlin plugin (Plugin ID &lt;code class=&quot;highlighter-rouge&quot;&gt;org.jetbrains.kotlin&lt;/code&gt;) itself. Please refer to &lt;a href=&quot;https://plugins.jetbrains.com/docs/intellij/plugin-dependencies.html&quot;&gt;Plugin Dependencies&lt;/a&gt; for more information.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;제시된 여러 문서를 따라가 보면 아래의 두 가지 작업으로 귀결됩니다.
우선 &lt;code class=&quot;highlighter-rouge&quot;&gt;plugin.xml&lt;/code&gt;에 아래의 코드를 추가하고,&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
&lt;span class=&quot;nt&quot;&gt;&amp;lt;depends&amp;gt;&lt;/span&gt;org.jetbrains.kotlin&lt;span class=&quot;nt&quot;&gt;&amp;lt;/depends&amp;gt;&lt;/span&gt;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle.kts&lt;/code&gt;이 플러그인 의존성 값을 받아오고 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt; 파일에다가 아래와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;java&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt; 플러그인 의존성을 추가해서 IntelliJ &lt;strong&gt;Kotlin&lt;/strong&gt; Plugin 의존성을 사용하도록 하면 됩니다.&lt;/p&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nn&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;platformPlugins = ..., java, Kotlin&lt;/span&gt;
&lt;span class=&quot;nn&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 해당 변경사항을 IDE가 인지할 수 있도록 &lt;code class=&quot;highlighter-rouge&quot;&gt;Sync Project with Gradle Files&lt;/code&gt;를 해주면 Kotlin 코드를 다룰 준비가 되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;psi-사용하기&quot;&gt;PSI 사용하기&lt;/h3&gt;
&lt;p&gt;실질적으로 코드를 다루는 작업은 IntelliJ platform에서 제공하는 인터페이스인 &lt;a href=&quot;https://plugins.jetbrains.com/docs/intellij/psi.html&quot;&gt;PSI(Program Structure Interface)&lt;/a&gt;를 통해서 진행합니다.
여기서 PSI란 &lt;a href=&quot;https://plugins.jetbrains.com/docs/intellij/implementing-parser-and-psi.html&quot;&gt;공식 문서&lt;/a&gt;에 적혀있는 것처럼 특정 언어를 다루기 쉽도록 IntelliJ Platform이 파싱한 AST 요소들 위에 부가정보(문법적인 정보나, 언어 특유의 속성)들을 더한 것입니다.
저희는 위에서 적었던 &lt;code class=&quot;highlighter-rouge&quot;&gt;platformPlugins = ..., Kotlin&lt;/code&gt;을 통해서 IntelliJ Kotlin Plugin이 제공하는 Kotlin PSI를 사용할 수 있게 되었습니다.&lt;/p&gt;

&lt;p&gt;즉, 위에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt; 의존성을 추가해 줌으로써 &lt;code class=&quot;highlighter-rouge&quot;&gt;org.jetbrains.kotlin.psi.KtClass&lt;/code&gt;와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;org.jetbrains.kotlin&lt;/code&gt; 패키지에 있는 내용을 우리가 만드는 플러그인 코드에서 사용할 수 있습니다.
결과적으로 우리가 만드는 플러그인에서 PSI tree에 있는 이 Kotlin PSI Element에 대해 다음과 같은 동작들을 해볼 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;해당 Element가 Class인지 Property인지 Function인지 판별&lt;/li&gt;
  &lt;li&gt;이 Element를 참조하고 있는 다른 Element로 이동&lt;/li&gt;
  &lt;li&gt;AST에 있는 하위 Element들은 어떤 것들이 있는지 확인&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;모든-ktclass-이름-출력&quot;&gt;모든 KtClass 이름 출력&lt;/h3&gt;
&lt;p&gt;Kotlin PSI를 사용해서 프로젝트에 있는 모든 &lt;code class=&quot;highlighter-rouge&quot;&gt;.kt&lt;/code&gt; 파일에 정의된 Kotlin Class의 이름을 출력해 보려면 아래와 같은 함수를 만들어서 사용해 볼 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;printKtClassNames&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Project&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;allModules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;forEach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;FilenameIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getAllFilesByExt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;kt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;moduleContentScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;mapNotNull&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;toPsiFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;KtFile&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ktFile&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ktFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;collectDescendantsOfType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;KtClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;forEach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ktClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ktClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래의 스크린샷은 기본 예제 프로젝트의 &lt;code class=&quot;highlighter-rouge&quot;&gt;MyProjectService.kt&lt;/code&gt;파일을 수정한 뒤에 &lt;code class=&quot;highlighter-rouge&quot;&gt;Run Plugin&lt;/code&gt;을 통해 실행된 테스트용 Sandbox IDE에서 동일한 프로젝트를 열었을 때 바깥쪽 IDE에 값들이 출력되는 모습입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/intellij-plugin/ktclass.png&quot; alt=&quot;KtClass 이름 출력&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Sandbox IDE에서 열린 프로젝트의 &lt;code class=&quot;highlighter-rouge&quot;&gt;KtClass&lt;/code&gt; 이름들이 아래쪽의 콘솔 창에 찍힌 것을 확인해 볼 수 있습니다.
다만 프로젝트가 열리는 시점에는 Indexing이 끝나지 않아 모듈이나 파일 목록들이 아직 구성되지 않은 상태일 수도 있기 때문에 위와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;DumbService.getInstance(project).runWhenSmart()&lt;/code&gt;를 사용해서 Indexing이 완료된 후에 실행될 수 있도록 했습니다.&lt;/p&gt;

&lt;h3 id=&quot;특정-프로퍼티-가져오기&quot;&gt;특정 프로퍼티 가져오기&lt;/h3&gt;
&lt;p&gt;그렇다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;KtClass&lt;/code&gt; 내부에 정의된 &lt;code class=&quot;highlighter-rouge&quot;&gt;bindView&lt;/code&gt;를 사용하는 프로퍼티와 연결된 XML ID는 어떻게 가져올 수 있을까요?&lt;/p&gt;

&lt;p&gt;클래스 안에 정의된 프로퍼티를 가져와서 그 PSI tree를 보면서 &lt;code class=&quot;highlighter-rouge&quot;&gt;bindView&lt;/code&gt;를 사용하고 있는지, 그리고 어떤 ID를 사용하는지 확인해 보면 됩니다.
현재 활성화된 파일의 PSI tree가 어떤 식으로 구성되어 있는지 간단하게 확인해 보기 위해 &lt;a href=&quot;https://plugins.jetbrains.com/docs/intellij/explore-api.html#31-use-internal-mode-and-psiviewer&quot;&gt;이 문서&lt;/a&gt;에 나와 있는 것처럼 IntelliJ Plugins Marketplace에 있는 &lt;em&gt;PsiViewer&lt;/em&gt; 플러그인을 사용했습니다.&lt;/p&gt;

&lt;p&gt;해당 플러그인을 사용하면 아래와 같이 현재 커서가 있는 곳의 PSI element가 전체 트리의 어떤 위치에 있는지 파악하는 것이 가능합니다.
&lt;img src=&quot;/assets/images/intellij-plugin/psi-viewer.png&quot; alt=&quot;PsiViewer plugin&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이러한 기능을 바탕으로 PSI tree를 확인해서 우리가 수정할 대상인 &lt;code class=&quot;highlighter-rouge&quot;&gt;bindView&lt;/code&gt; Delegate를 사용하는 프로퍼티 목록을 가져올 수 있습니다.
가져오는 방법은 여러 가지가 있겠지만, 저는 아래와 같은 코드로 접근했습니다.&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;KtClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getBindViewProperties&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getProperties&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;mapNotNull&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;bindViewCall&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delegate&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expression&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;castSafelyTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;KtCallExpression&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;takeIf&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;referenceExpression&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;bindView&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;firstArgument&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bindViewCall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;valueArgumentList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arguments&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;xmlId&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstArgument&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getArgumentExpression&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lastChild&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;xmlId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BindViewProperty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;data class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BindViewProperty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;KtProperty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;xmlId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;프로퍼티의-이름을-변경하기&quot;&gt;프로퍼티의 이름을 변경하기&lt;/h3&gt;
&lt;p&gt;위쪽 단락에서 받아온 Kotlin PSI의 &lt;code class=&quot;highlighter-rouge&quot;&gt;KtProperty&lt;/code&gt; 타입은 &lt;code class=&quot;highlighter-rouge&quot;&gt;PsiNamedElement&lt;/code&gt;를 구현한 타입입니다.
따라서 아래와 같이 함수를 만들어서 Reference를 포함한 모든 장소의 이름을 변경하고, 그 변경사항을 반영할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PsiNamedElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;renameAllReferences&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Project&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;updateAndCommit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;files&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ReferencesSearch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;handleElementRename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;containingFile&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;setName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[Rename] ${this.elementType} ${this.name} -&amp;gt; $newName&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;plus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;containingFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;filterNotNull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;updateAndCommit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Project&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Iterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;PsiFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;DumbService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;runWhenSmart&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;WriteCommandAction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;runWriteCommandAction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;filesToCommit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;filesToCommit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;toSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;forEach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;commitAndUnblockDocument&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;View binding에서는 snake case 대신에 lower camel case를 사용하므로, 실제 코드에서는 아래와 같이 간단한 변환 함수를 활용해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;renameAllReferences()&lt;/code&gt;를 호출해 주었습니다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;snakeToLowerCamelCase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'_'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;joinToString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;capitalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;decapitalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그 밖에도 &lt;code class=&quot;highlighter-rouge&quot;&gt;PsiElement.astReplace&lt;/code&gt;를 활용하면 이름을 변경하는 것을 넘어서 직접 AST를 조작하는 것 또한 가능합니다.
가령 아래와 같이 임의의 &lt;code class=&quot;highlighter-rouge&quot;&gt;PsiElement&lt;/code&gt;를 white space로 변경시킬 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;psiElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;astReplace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;PsiWhiteSpaceImpl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;action으로-등록해서-사용&quot;&gt;Action으로 등록해서 사용&lt;/h3&gt;
&lt;p&gt;앞서 말한 동작들이 프로젝트 로딩 시점마다 매번 실행되는 것은 플러그인이라는 특성상 그다지 바람직하지 않은 일입니다.
따라서 IntelliJ에서는 &lt;a href=&quot;https://plugins.jetbrains.com/docs/intellij/basic-action-system.html&quot;&gt;action&lt;/a&gt;을 등록할 수 있게 해 두었습니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;plugins.xml&lt;/code&gt;에 아래와 같이 작성하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Run Plugin&lt;/code&gt;을 돌려서 켜진 Sandbox IntelliJ를 확인해 보면, 상단의 Tools 메뉴 가장 위에 Action이 등록된 것을 볼 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;actions&amp;gt;&lt;/span&gt;
    ...
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;action&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;path.to.the.action.class&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;description=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;text=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;add-to-group&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;anchor=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;first&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;group-id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ToolsMenu&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/action&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/actions&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;에 지정한 클래스로 가서 Action에서 수행할 내용을 적어주면 됩니다.
저희 플러그인에서는 아래 코드처럼 커서가 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;KtClass&lt;/code&gt;에 대해서만 리팩토링을 수행하도록 했습니다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BindViewRefactoring&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnAction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnActionEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Set the availability based on whether a project is open&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;presentation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isEnabledAndVisible&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;project&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;actionPerformed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnActionEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;elementAtCursor&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;CommonDataKeys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;PSI_FILE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;findElementAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;CommonDataKeys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;CARET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;targetElement&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elementAtCursor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parentOfType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;KtClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt;

        &lt;span class=&quot;nc&quot;&gt;Messages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;showOkCancelDialog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&quot;리팩토링 대상: ${targetElement?.name}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&quot;View Binding&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&quot;실행&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&quot;취소&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;Messages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getInformationIcon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Messages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;OK&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;targetElement&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;KtClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;refactorBindViewProperties&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;targetElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;마무리하며&quot;&gt;마무리하며&lt;/h2&gt;
&lt;p&gt;이러한 과정을 거쳐서 작성한 플러그인 코드를 빌드 하여 Android Studio에 설치하고, 리팩토링에 빠르게 사용해 볼 수 있었습니다.
&lt;img src=&quot;/assets/images/intellij-plugin/plugin.png&quot; alt=&quot;Android Studio에 설치한 쏘카 플러그인&quot; /&gt;&lt;/p&gt;

&lt;p&gt;또한 작성한 플러그인의 기능에는 전처리/후처리를 좀 더 편하게 할 수 있도록 위에서 언급했던 프로퍼티 변경 기능 외에도 아래와 같은 기능들을 추가했습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;View Binding Migration 페이지에 있는 것처럼 레이아웃을 &lt;code class=&quot;highlighter-rouge&quot;&gt;R.layout.~&lt;/code&gt; Resource 대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;...Binding&lt;/code&gt; 클래스로부터 받아와서 초기화하는 코드 삽입 기능&lt;/li&gt;
  &lt;li&gt;IntelliJ에서 제공하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;OptimizeImportsProcessor&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ReformatCodeProcessor&lt;/code&gt; 등을 사용해서 수정한 코드를 다시 정리하는 기능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;덕분에 &lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Fragment&lt;/code&gt;, Custom View 등 100개가 넘는 파일에 있던 &lt;code class=&quot;highlighter-rouge&quot;&gt;bindView&lt;/code&gt; 프로퍼티들을 한꺼번에 수정할 수 있었습니다.
PR에서 코드 리뷰 과정을 거치는 도중, View Binding 초기화 코드를 수정하면 좋겠다는 의견이 있어서 이를 전체적으로 반영할 때에도 하나하나 파일을 찾아가며 고칠 필요가 없던 것도 큰 이득이었습니다.&lt;/p&gt;

&lt;p&gt;그뿐만 아니라 현재는 이 플러그인을 확장해서 Live Template으로 하기에는 까다로운 템플릿 코드 기능을 추가하는 등, 더 다양한 형태로 활용하고 있습니다.
이런 식으로 앞으로도 IntelliJ 플러그인을 통해서 개발자들의 소중한 개발 시간을 조금이나마 절약해 볼 수 있으면 좋겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;ps&quot;&gt;P.S.&lt;/h3&gt;
&lt;p&gt;2021년 11월 말, JetBrains에서 차세대 IDE &lt;a href=&quot;https://www.jetbrains.com/fleet/&quot;&gt;Fleet&lt;/a&gt;을 발표했습니다.
짧은 지원자 신청 기간을 거쳐 현재는 Closed Preview를 진행 중인데요, Fleet에서 Plugin 지원은 어떻게 진행할지, Language Server에 대한 정책은 어떻게 바뀔지 흥미롭습니다.
비록 플러그인을 작성하는 방식이 기존과 달라질 수도 있겠지만, 여기서 진행했던 리팩토링 자동화 경험에 약간의 변주만 더한다면 수월하게 작업할 수 있으리라 생각합니다.&lt;/p&gt;</content><author><name>jian</name></author><category term="dev" /><category term="kotlin" /><category term="intellij" /><category term="android-studio" /><category term="plugin" /><summary type="html">안녕하세요, 쏘카 안드로이드 팀의 지안입니다.</summary></entry><entry><title type="html">자동차 배터리를 더 소중하게 공학적으로 관리하기 #2</title><link href="https://tech.socarcorp.kr/mobility/2022/01/18/socar-mobility-lab-battery-management-process-second-stage.html" rel="alternate" type="text/html" title="자동차 배터리를 더 소중하게 공학적으로 관리하기 #2" /><published>2022-01-18T03:00:00+00:00</published><updated>2022-01-18T03:00:00+00:00</updated><id>https://tech.socarcorp.kr/mobility/2022/01/18/socar-mobility-lab-battery-management-process-second-stage</id><content type="html" xml:base="https://tech.socarcorp.kr/mobility/2022/01/18/socar-mobility-lab-battery-management-process-second-stage.html">&lt;p&gt;안녕하세요. 쏘카 모빌리티 Lab의 찰리입니다. &lt;a href=&quot;https://socarcharlie.github.io/mobility/2021/07/20/socar-mobility-lab-battery-management-process-first-stage.html&quot;&gt;지난 글&lt;/a&gt;에서는 10,000대가 넘는 차량을 운영하는 쏘카에서, 차량의 배터리 상태 관리를 위한 공학적인 접근 방식과 해결 방법에 대해 다뤘습니다. 이번 글에서는 배터리 방전을 사전에 막기 위해 알람 서비스를 도입하고, 운영에 도입한 내용을 공유해 보고자 합니다. 다소 전문적인 지식이 필요했던 지난번 글에 비해 이번 글은 누구나 쉽게 읽으실 수 있을 거라 생각합니다.&lt;/p&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;의도치 않은 실수들로 생기는 배터리 방전&lt;/li&gt;
  &lt;li&gt;적당한 차량 상태 조회 주기 찾기&lt;/li&gt;
  &lt;li&gt;차량이 방전될 상태인지 판단하기&lt;/li&gt;
  &lt;li&gt;그래서 알림은 어떻게 보내지나요?&lt;/li&gt;
  &lt;li&gt;조금만 더 세심하게 다뤄주세요. 다 같이 쓰는 차니까요.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;의도치-않은-실수들로-생기는-배터리-방전&quot;&gt;의도치 않은 실수들로 생기는 배터리 방전&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://socarcharlie.github.io/mobility/2021/07/20/socar-mobility-lab-battery-management-process-first-stage.html&quot;&gt;지난 글&lt;/a&gt;을 보면 쏘카에서 일어나는 배터리 방전의 60% 이상이 고객의 사용 습관과 밀접하다고 말씀드렸습니다. 그러나 배터리 방전을 고객께서 의도적으로 내지는 않습니다. 대부분은 어떤 상황에서 방전이 되는지 잘 모르시기 때문에 일어나곤 합니다.&lt;/p&gt;

&lt;p&gt;저 역시 의도치 않게 쏘카 차량의 방전을 일으킬만할 경험이 있습니다. 제가 보유하고 있는 차는 시동 버튼을 두 번 눌러 시동을 완전히 종료시키는 반면, 쏘카 차량 (현대/기아차, Jeep)은 시동 버튼을 한 번만 눌러도 시동 종료가 이루어졌습니다. 기어 상태도 시동을 종료하면 자동으로 주차 모드로 바뀌는 제 차와 달리 기어 봉을 직접 P로 옮겨주어야 했습니다. 사실 자동 변속기 차량에서 시동을 P에 두고 시동을 종료하는 일은 대단히 당연합니다. 단지 제가 익숙한 방식과 조금 달랐기에 이런 실수를 저질렀고, 그 결과 차량 반납 불가의 메시지를 받았습니다. 저와 비슷한 상황에 놓였던 고객과 핸들러 입장에서 가시동이나 기어봉 P가 아닌 D 혹은 R 모드 중 강제 반납으로 인한 방전 상황 노출이 대단히 쉬운 일임을 깨닫게 된 순간이었습니다.&lt;/p&gt;

&lt;p&gt;주위에 비슷한 사례가 있나 싶어 지인들에게 물어보니, 쏘카 패스를 구독하는 저의 친구 역시 비슷한 경험이 있었습니다. 몹시 더운 여름 어느날 주차 중에 에어컨을 켜고 싶어서 가시동 상태로 송풍기를 열심히 돌리면서 노래도 들었다고 합니다. 그렇게 한 시간 정도가 지났고 차를 다시 움직여 이동하려고 하는데 시동이 걸리지 않았다고 합니다. 친구는 가시동 상태에서 송풍기를 돌리고(에어컨 컴프레셔는 멈춰있어서 바람만 나왔을텐데) 차량 스피커로 음악을 들으면 필요한 전력을 모두 차량 배터리에서 가져 온다는 사실을 몰랐습니다.&lt;/p&gt;

&lt;p&gt;이 외에도 고객께서 전혀 의도하지 않았지만 차량의 전원관리에 나쁜 영향을 미칠 수 있는 차량 운용으로 인해 방전이 생기는 경우는 다양할 거라 생각했습니다. 어떻게 해야 고객께서도 방전을 겪지 않아 기분이 좋고 쏘카도 관리 이슈를 줄일 수 있을까요?&lt;/p&gt;

&lt;p&gt;저는 이렇게 생각했습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“고객께서 실수하지 않도록 우리가 도와드리자. 알림을 보내드리면 상황 인지를 빨리하실 수 있겠지?”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;결론은 고객에게 어떤 형태로든 &lt;strong&gt;“알림을 드리자!”&lt;/strong&gt;였습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;적당한-차량-상태-조회-주기-찾기&quot;&gt;적당한 차량 상태 조회 주기 찾기&lt;/h2&gt;

&lt;p&gt;고객에게 방전될 수 있는 상황임을 알리는 알림을 보내기 위해서는, 먼저 현재 차량의 상태를 알아야 합니다. 쏘카 차량에는 관제 장치가 붙어있는데, 이 장치로부터 차량 상태에 대한 데이터를 주기적으로 받을 수 있습니다. 데이터를 받는 주기는 다음과 같이 3가지 상황에 따라 다릅니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;일반 주행 혹은 가시동 상황일 때: 2분에 1회&lt;/li&gt;
  &lt;li&gt;시동 OFF 후 정차 중인 상황일 때: 30분에 1회&lt;/li&gt;
  &lt;li&gt;문열림/문잠금/시동 상태의 변화가 일어날 때: 각각 1회&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위의 주기는 하나의 차량에서 어떤 주기로 차량 정보 데이터를 올려주는지에 대한 내용입니다. 쏘카에서 운영하는 총 차량은 10,000대가 넘고, 차량 각각에서 일어나는 상태 변화 시점은 제각각입니다. 따라서 하나의 시스템이 많은 차량을 다루기 위해선 일정 시점마다 전체 차량을 조회하고, 각 차량의 상태 시점과 이벤트 시점의 시간 차이와 상태 변화 추이를 각각 계산해야 합니다. 따라서 전체 차량의 상태 조회 주기가 너무 늦으면 방전 상태를 늦게 판단할 가능성이 높아지고, 너무 빠르게 하면 알람이 너무 자주 가게 됩니다. 따라서 &lt;strong&gt;전체 차량 상태 조회의 적당한 주기를 찾는 것이 중요합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이를 위해 가장 먼저 해야 할 일은 차량 방전이 일어날만한 시나리오를 생각해 보고, 각 &lt;strong&gt;시나리오별 전류가 어느 정도로 빨리 소모되는지 측정하는 것&lt;/strong&gt;이었습니다. 또한 차종별로 장착된 부품의 사이즈나 전력 소모량이 모두 다르기 때문에, 각 차종별로 위의 시나리오에 맞추어 실험을 따로 진행해야 하는 것도 고려해야 했습니다.&lt;/p&gt;

&lt;p&gt;처음에는 차량 방전이 일어나기 쉬운 사용 시나리오를 찾는 일부터 시작해보았습니다. 가시동 중 노래 듣기, 송풍기(1~n단까지 모두 다른 케이스로 가정했음), 전조등, 미등, 상향등, 경고등, 실내등 등등 모든 전력 소모 및 방전 요소를 모두 조합한 시나리오를 세웠고 &lt;strong&gt;조합한 시나리오별로 전류가 얼마정도 소모되는지 모두 측정&lt;/strong&gt;하기로 했습니다.&lt;/p&gt;

&lt;p&gt;전류 측정은 초등학교 시절 한번 즈음 모두가 거쳐갔을 라디오 조립 키트의 전류 측정보다 아주 조금 어려운 정도입니다 (&lt;del&gt;쉽다는 말을 어렵게 해 보았습니다.&lt;/del&gt;). 직접 실험을 해보고 싶으신 분도 계시리라 생각하여 측정법에 대해 설명드리겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;우선 배터리의 - 단자에 연결된 터미널을 제거합니다.&lt;/li&gt;
  &lt;li&gt;배터리가 제거되는 순간 자동차에 연결된 IBS 단자 (Intelligent Battery Sensor)는 초기화됩니다. 이 센서는 배터리의 상태와 관련된 값을 수집하는 센서인데 이 센서의 초기화 부분은 차량 제조사와 차종마다 모두 상이하므로 다루지 않도록 하겠습니다. 차량 제조사 매뉴얼에 보면 이 센서의 초기화와 관련된 내용이 상세히 적혀 있으니 참고하시면 좋습니다.&lt;/li&gt;
  &lt;li&gt;전력계의 모드를 전류 측정으로 전환합니다.&lt;/li&gt;
  &lt;li&gt;제거된 터미널에 전력계의 양극 부를 연결하고, 배터리의 - 단자에는 전력계 음극 부를 연결합니다. 이때 측정기의 리드 케이블은 클립형이 좋으며 길고 튼튼할수록 좋습니다. 측정할 때는 보닛을 닫아두는 게 좋기 때문입니다.&lt;/li&gt;
  &lt;li&gt;잘 연결이 되었다면 전력계에 전류 값이 표시됩니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위의 설명은 고전적인 측정기를 사용하는 방법입니다. 요즈음에는 블루투스로 연동하여 핸드폰으로 값을 받을 수 있는 전류 측정기가 있어서 측정이 비교적 쉽습니다. 블루투스 전류 측정기의 자동차 단자 연결법도 위와 동일합니다.&lt;/p&gt;

&lt;p&gt;측정기 연결이 잘 되었다면 미리 세워둔 시나리오별로 전류 소모의 변화를 모두 기록합니다. 다양한 차종에 대해 실험하다 보니 하루에 끝내기는 어려웠고 실험 완료까지 수 일이 걸렸습니다. 측정이 완료된 시점에서 보니 생각보다 방전을 일으키키 정말 쉬운 물건이 자동차구나 싶었습니다.&lt;/p&gt;

&lt;p&gt;시나리오 중 한 가지 예를 아래에 공유드리도록 하겠습니다. 실험값과 차종은 모두 예시입니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Avg[A]&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Max[A]&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;검출 여부&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;비고&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;실내등(개당)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;△&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;문 열림 상태로 간접 추론&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ACC1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2.1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ACC2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7.5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;12&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;송풍기 1단&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;송풍기 2단&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4.2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;송풍기 3단&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6.8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;송풍기 4단&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;11.2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;라이트 1단&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;△&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;단계는 나오지 않음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;라이트 2단&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8.8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;△&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;단계는 나오지 않음, 차종별로 ACC2부터 가능함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;라이트 3단(High)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9.8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;△&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;단계는 나오지 않음, 차종별로 ACC2부터 가능함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;비상등&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5.5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그리고 구현 가능한 시나리오는 다음과 같았습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;일반적인 시나리오

S1. 시동 OFF + 문 열림: 0.6A 소모
S2. ACC1 단독: 2.1A 소모
S3. ACC2 단독: 7.5A 소모
S4. ACC1 + Light 1단 (흔한 유형): 2.9A 소모
S5. ACC2 + Light 2단 (흔한 유형): 16.3A 소모
S6. ACC2 + 송풍기 2단 (흔히 말하는 차박): 11.7A 소모

최악의 시나리오

SW. ACC2 + 실내등 2개 (문 앞뒤 열림) + 송풍기 4단계 + Light 3단 + 비상등 +핸드폰 충전기: 32.7A 소모
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 이렇게 세워둔 시나리오 별로 각 차량별 정격 용량의 절반에 도달하기까지 걸리는 시간까지의 시간을 측정했습니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 아래는 60Ah 배터리를 사용하는 차량의 경우입니다. 각 S1 - S6는 시나리오를 뜻하며, 값은 시간(hour)입니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;SW&lt;/th&gt;
      &lt;th&gt;S1&lt;/th&gt;
      &lt;th&gt;S2&lt;/th&gt;
      &lt;th&gt;S3&lt;/th&gt;
      &lt;th&gt;S4&lt;/th&gt;
      &lt;th&gt;S5&lt;/th&gt;
      &lt;th&gt;S6&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0.5&lt;/td&gt;
      &lt;td&gt;27.0&lt;/td&gt;
      &lt;td&gt;7.7&lt;/td&gt;
      &lt;td&gt;2.2&lt;/td&gt;
      &lt;td&gt;5.6&lt;/td&gt;
      &lt;td&gt;1.0&lt;/td&gt;
      &lt;td&gt;1.4&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이렇게 모든 차종에 대해 시나리오에 따른 전류 소모 측정 실험을 마친 후, 전체 차량의 상태 조회의 적당한 주기를 &lt;strong&gt;10분&lt;/strong&gt;으로 결정지었습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;차량이-방전될-상태인지-판단하기&quot;&gt;차량이 방전될 상태인지 판단하기&lt;/h2&gt;

&lt;p&gt;위에서 정의한 시나리오는 전류 소모 측정을 위해 어느 정도 미리 생각해두어 생각한 틀일 뿐, 실제로 쏘카 데이터를 기반으로 만들어진 시나리오는 아닙니다. 이제 수집된 데이터로부터 실제로 방전이 될만한 상황인지를 판단해야 합니다. 저희는 쏘카 내 데이터로부터 이런 시나리오를 분석하여 정의하기로 했습니다.&lt;/p&gt;

&lt;p&gt;앞서 쏘카 차량에는 관제 단말기가 부착되어 있고, 이 단말기로부터 차량 주행과 관련된 데이터를 주기적으로 수집하고 있다고 말씀 드렸습니다. 수집하는 데이터 중에는 시동/가시동/정지 여부, 전조등 켜짐/꺼짐 여부, 전압 정보 등등 고객님의 차량 운용 패턴과 관련된 데이터가 모두 담겨있습니다. 따라서 &lt;strong&gt;과거의 방전 관련 CS 콜이 들어온 시간을 전/후로 주행 데이터를 살펴보면 문제 발생을 일으키는 주요한 운용 패턴을 발견할 수 있습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;예를 들면, 여름철에 가장 많이 들어온 방전 관련 CS 콜을 살펴보면 위의 시나리오 중 S6이 가장 많습니다. 주행은 하고 있지만 엔진이 작동하기에 추가적인 기름 소모는 아쉽고, 차에서 좀 쉬고 싶기는 해서 송풍기에서 나오는 바람을 좀 쐬고 있다 보니 발생하는 일입니다. 그 외에도 희귀하지만 인상 깊었던 상황을 공유드리자면, 자주 방전이 일어나 발전기까지 체크했는데도 방전 문제가 개선되지 않았던 차량에 대한 신고를 받고 데이터를 살펴보니, 퓨즈단의 배선이 잘못되어 시동이 꺼진 후에도 암전류가 지속적으로 일어났던 상황이었습니다. 다음의 그림은 각각 “블루투스 계측기를 이용한 전류 측정 사진”과 “같은 잔존 수명을 가진 배터리가 암전류의 유무에 따라 시간당 전압 변화율이 어떻게 달라지는지 보여주는 예시 차트”입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/socar-mobility-lab-battery-management-process-second-stage/Figure-2.jpg&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;블루투스 계측기를 이용한 전류 측정&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/socar-mobility-lab-battery-management-process-second-stage/Figure-3.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;같은 잔존 수명을 가진 배터리가 암전류의 유무에 따라 시간당 전압 변화율이 어떻게 달라지는지 보여주는 예시&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;실험과 데이터를 보기 전에는 고객께서 단순히 전조등만 켜 놓았거나, 송풍기만 켜 놓았다거나, 실내등만 켜두는 등의 단일 조작 위주의 시나리오가 많을 거라 생각했습니다. 그러나 실험과 데이터를 통해, 생각과는 달리 꽤나 다양한 요소가 결합된 시나리오가 많다는 사실을 알 수 있었습니다.&lt;/p&gt;

&lt;p&gt;결과적으로 저희는 수집된 데이터가 다음과 같은 조건일 때 방전 알림을 보내야 하는 상황이라고 판단했습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;시동 종료 후 가시동(ACC) 10분 이상 지속 할 때&lt;/li&gt;
  &lt;li&gt;시동 종료 후 10분간 문 잠금/열림 연속 10회 이상 시도할 때&lt;/li&gt;
  &lt;li&gt;전조등이 켜져 있을 때&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;데이터 수집은 위에서 정한 대로 10분마다 이루어지며 1~3은 모두 OR 조건으로 엮입니다. 따라서 어느 한 조건이라도 충족이 되면 그 차량은 알림의 대상이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/socar-mobility-lab-battery-management-process-second-stage/Figure-4.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;실행 프로세서의 순서도. 실제 시스템 구축은 모비딕 팀 스팍께서 해주셨습니다.&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;그래서-알림은-어떻게-보내지나요&quot;&gt;그래서 알림은 어떻게 보내지나요?&lt;/h2&gt;

&lt;p&gt;위 과정에 의해 DB에 알림 대상이 되는 차량들이 저장되며, 이후에는 쏘카의 서비스 서버가 이 DB를 조회해 알림을 보냅니다.&lt;br /&gt;
서비스 서버에서는 대상 차량 확인 후 다음을 고려하여 알람 주기 및 방식을 정합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;알림 주기
    &lt;ul&gt;
      &lt;li&gt;고객께서 차량 정차 후 정차된 차량으로 돌아오기 어려울 정도로 멀리 떠나기까지 걸리는 시간을 고려해야 합니다.&lt;/li&gt;
      &lt;li&gt;차량을 정차(강제 반납의 가능성이 높음) 후 고객께서 다른 교통수단으로 갈아타서 이동을 시작하거나, 개인 사정으로 어떠한 연락에도 즉시 확인 및 응답이 불가능하다면 그 고객에게는 어떠한 알림도 무의미합니다.&lt;/li&gt;
      &lt;li&gt;따라서 고객의 다음 행동이 구체화되어 차량으로 다시 돌아오기엔 어려워지는 상황이 오기 전에 미리 연락을 취해야 합니다.&lt;/li&gt;
      &lt;li&gt;이 시간은 과거 CS 콜 분석을 통해 &lt;strong&gt;10분&lt;/strong&gt;으로 결정하였습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;알림 방식 소모 비용
    &lt;ul&gt;
      &lt;li&gt;기존에 쏘카에서 사용하고 있으며 고객에게 친숙한 채널을 최대한 활용하기로 했습니다.&lt;/li&gt;
      &lt;li&gt;비용적으로도 저렴한 &lt;strong&gt;카카오톡 알림&lt;/strong&gt;을 활용하기로 결정했습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;전체 과정을 최종적으로 정리해 보면 다음과 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;전체 차량에 대한 상태 데이터를 10분마다 수집합니다.&lt;/li&gt;
  &lt;li&gt;미리 세워둔 시나리오를 기반으로 현재 차량이 방전이 될만한 상태인지 판단합니다.&lt;/li&gt;
  &lt;li&gt;방전이 될만한 차량을 발견하면, 해당 차량과 고객에 대한 데이터를 DB에 적재합니다.&lt;/li&gt;
  &lt;li&gt;쏘카 서비스 서버는 DB에서 알림을 보낼 차량과 고객을 확인합니다.&lt;/li&gt;
  &lt;li&gt;해당 고객의 카카오톡으로 10분마다 방전 주의 알림을 보냅니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;조금만-더-세심하게-다뤄주세요-다-같이-쓰는-차니까요&quot;&gt;조금만 더 세심하게 다뤄주세요. 다 같이 쓰는 차니까요.&lt;/h2&gt;

&lt;p&gt;위의 기준으로 쏘카는 본 서비스를 2021년 2월부터 투입했습니다. 성과를 간략히 말씀드리면, &lt;strong&gt;동기 대비 이용건수가 8% 늘어난 상황에서 (2021년 n월 기준) 긴급 출동 건수 35% 감소가 이루어졌으며 방전 비율도 절반 정도 감소 (2021년  n월 기준)&lt;/strong&gt; 했음을 확인했습니다 (회사의 영업 기밀이기에 자세한 기준을 공개하기 어려운 점 양해 부탁드립니다.).&lt;/p&gt;

&lt;p&gt;본 아이디어의 기본 개념은 “고객께서 실수할 확률 자체를 낮추어드리자”입니다. 누구도 쏘카의 차량을 일부러 고장 내고 싶지 않으리라 생각합니다. 단지 자동차에 대한 경험적 이해가 아직 부족해서 혹은 피할 수 없는 상황에 놓여서, 어쩌면 쏘카 정비의 미진한 점으로 인한 일들이 있었겠죠. 이런 상황에 놓이지 않도록 미리 도움을 드리는 일도 쏘카가 기술적으로 해결할 일이라고 생각합니다.&lt;/p&gt;

&lt;p&gt;쏘카는 &lt;strong&gt;누구나&lt;/strong&gt; 이용할 수 있고, &lt;strong&gt;누구나&lt;/strong&gt; 이용하는 ‘&lt;strong&gt;카-셰어링&lt;/strong&gt;’ 서비스입니다. 따라서 &lt;strong&gt;쏘카 차량의 주인은 “쏘카”가 아닌 “여러분 모두”라고 생각합니다.&lt;/strong&gt; 쏘카는 단지 모두가 사용하는 차량에 날개를 달아주는 도우미라고 생각합니다. 앞으로도 좋은 날개를 달기 위해 고객의 주행 환경과 경험 개선을 위한 다양한 기술 기반 아이템을 많이 발굴하도록 노력하겠습니다. 쏘카를 이용해 주시는 쏘카 차량의 주인이신 여러분들께서도 여러분들의 차량을 조금만 더 아껴주시면 감사하겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;쏘카의 모빌리티 Lab&lt;/strong&gt;은 모두 높은 수준의 기계 공학 지식을 보유한 인력으로 이루어졌으며, 쏘카의 풍부한 차량 데이터에 기계 공학 지식을 녹여 운영에 필요한 최적 솔루션을 만들고 있습니다. (우리에게 힘을 더해주실 우수한 분을 모시고 있습니다. 언제든지 지원해 주세요)&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>charlie</name></author><category term="mobility" /><category term="mechanical engineering" /><category term="chemical engineering" /><category term="data" /><summary type="html">안녕하세요. 쏘카 모빌리티 Lab의 찰리입니다. 지난 글에서는 10,000대가 넘는 차량을 운영하는 쏘카에서, 차량의 배터리 상태 관리를 위한 공학적인 접근 방식과 해결 방법에 대해 다뤘습니다. 이번 글에서는 배터리 방전을 사전에 막기 위해 알람 서비스를 도입하고, 운영에 도입한 내용을 공유해 보고자 합니다. 다소 전문적인 지식이 필요했던 지난번 글에 비해 이번 글은 누구나 쉽게 읽으실 수 있을 거라 생각합니다.</summary></entry><entry><title type="html">차량용 단말을 위한 IoT 파이프라인 구축기 #1</title><link href="https://tech.socarcorp.kr/mobility/2022/01/06/socar-iot-pipeline-1.html" rel="alternate" type="text/html" title="차량용 단말을 위한 IoT 파이프라인 구축기 #1" /><published>2022-01-06T00:00:00+00:00</published><updated>2022-01-06T00:00:00+00:00</updated><id>https://tech.socarcorp.kr/mobility/2022/01/06/socar-iot-pipeline-1</id><content type="html" xml:base="https://tech.socarcorp.kr/mobility/2022/01/06/socar-iot-pipeline-1.html">&lt;div class=&quot;photo-copyright&quot;&gt;
Photo by &lt;a href=&quot;https://unsplash.com/@mbenna?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Mike Benna&lt;/a&gt; on &lt;a href=&quot;https://unsplash.com/s/photos/pipeline?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt;
&lt;/div&gt;

&lt;h2 id=&quot;떼려야-뗄-수-없는-관계-단말과-서비스&quot;&gt;떼려야 뗄 수 없는 관계, 단말과 서비스&lt;/h2&gt;

&lt;p&gt;안녕하세요. 모빌리티 플랫폼 그룹 - 모비딕 팀의 스팍입니다.&lt;/p&gt;

&lt;p&gt;쏘카가 서비스를 제공하기 위해서는 &lt;strong&gt;차량의 상태 정보&lt;/strong&gt;가 필수적입니다. 사용이 끝난 차량이 정상적으로 제 위치에 안전한 상태로 돌아왔는지 언제든지 확인할 수 있어야 합니다.&lt;/p&gt;

&lt;p&gt;따라서 차량의 상태 정보를 수집하여 서버에 전달하며, 고객의 요청에 따라 차량을 제어해주는 장치가 필요합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/iot-pipeline-1/pipeline_concept.jpg&quot; alt=&quot;&quot; width=&quot;75%&quot; height=&quot;75%&quot; style=&quot;display: block; margin: 0 auto&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;잠깐-쏘카의-구형-단말을-돌아봅시다&quot;&gt;잠깐 쏘카의 구형 단말을 돌아봅시다&lt;/h2&gt;

&lt;p&gt;서비스 초기부터 쏘카는 차량 내에 서비스를 위한 단말을 장착하여 사용하고 있었습니다(편의상 구형 단말이라 부르겠습니다). 그리고 서비스가 급격하게 성장하던 시절에도 이 단말은 그럭저럭 제 역할을 해주었죠.&lt;/p&gt;

&lt;p&gt;이 구형 단말이 개발될 당시에는 운영 편의성을 위한 적합한 기술들이 아직 등장하기 전이었습니다. 따라서 단말을 제어할 때는 단말을 식별할 수 있는 고유번호인 전화번호를 이용하여 SMS 메시지를 통해 제어하였고, 단말이 데이터를 보낼 때는 웹서버에 데이터를 보내듯 HTTP로 데이터를 전달하였습니다.&lt;/p&gt;

&lt;p&gt;이러한 구형 단말은 잠재적인 문제를 갖고 있었습니다. 그중 몇 가지를 꼽아보자면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SMS의 특성상 단말에 명령이 도달하는 데 시간이 많이 소요됩니다. 게다가 이 시간은 모든 지역에서 동일하지 않고 서울에서 멀어질수록 오래 걸리는 경향이 있습니다.&lt;/li&gt;
  &lt;li&gt;데이터 수집을 HTTP로 하다 보니 이를 위한 웹서버가 필요합니다.&lt;/li&gt;
  &lt;li&gt;데이터 전달 요청이 급증하면서 서버에 부하가 걸리면 데이터 수집에 지연이 발생합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/iot-pipeline-1/old_device_arch.jpg&quot; alt=&quot;&quot; width=&quot;75%&quot; height=&quot;75%&quot; style=&quot;display: block; margin: 0 auto&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;이렇게-된-이상-새로운-단말을-만든다&quot;&gt;이렇게 된 이상 새로운 단말을 만든다!&lt;/h2&gt;

&lt;p&gt;이러한 문제를 해결하기 위해 새로운 단말을 만들기로 하였습니다.&lt;/p&gt;

&lt;p&gt;새로운 단말을 만들 때 기존 단말이 갖고 있던 한계점과 문제를 보완하기 위해 아래와 같은 요구사항들을 세웠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP를 통한 단말 데이터 수집을 더는 않는다. -&amp;gt; 단말 메시지보다 HTTP 프로토콜이 더 많은 네트워크 자원을 소모해야 할 이유가 없음.&lt;/li&gt;
  &lt;li&gt;SMS를 통한 차량 제어를 더는 하지 않는다. -&amp;gt; 메시지 도달 시간이 환경에 따라 다르고 발송할 때마다 비용이 발생하는 방식에서 탈피.&lt;/li&gt;
  &lt;li&gt;데이터 전달이 급증할 때 유연하게 대응할 수 있어야 함 -&amp;gt; 트래픽에 유동적으로 대응이 힘든 웹서버를 사용해서는 안 됨.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;해서, 위와 같은 요구사항에 맞춰 신규 단말은 &lt;a href=&quot;https://ko.wikipedia.org/wiki/MQTT&quot;&gt;MQTT&lt;/a&gt; 프로토콜 기반의 통신 방식을 채택하였습니다.&lt;/p&gt;

&lt;p&gt;MQTT를 단말 프로토콜로 선정한 이유는, 무엇보다 프로토콜 자체가 제한적인 IoT 기기에서 대용량의 데이터를 전송하기 위한 프로토콜로써 설계가 되었다는 점입니다.&lt;/p&gt;

&lt;p&gt;그리고 Publisher/Subscriber 구조로 되어 있어 여러 단말에 메시지를 퍼트리거나 상태 정보를 수집하는 것도 직접 각각의 단말들에 P2P로 연결할 필요 없이 메시지 브로커의 중개를 따르면 되므로 네트워크 관리 측면에도 용이합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/iot-pipeline-1/MQTT_protocol_example_without_QoS.png&quot; alt=&quot;출처:ko.wikipedia.org/wiki/MQTT&quot; width=&quot;45%&quot; height=&quot;45%&quot; style=&quot;display: block; margin: 0 auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 MQTT는 국제 표준화된 (ISO 표준 ISO/IEC PRF 20922) 프로토콜이므로 별도로 메시지 브로커를 개발할 필요 없이 이미 존재하는 수많은 메시지 브로커 중 하나를 선택하여 사용하면 된다는 것도 장점입니다.&lt;/p&gt;

&lt;p&gt;MQTT를 지원하는 메시지 브로커는&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mosquitto.org/&quot;&gt;mosquitto&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://vernemq.com/&quot;&gt;VernaMQ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.hivemq.com/&quot;&gt;HiveMQ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.rabbitmq.com/&quot;&gt;RabbitMQ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정도가 있습니다.&lt;/p&gt;

&lt;p&gt;하지만, 위에 나열된 MQTT 브로커들을 직접 운영한다고 하면 아래와 같은 고민에 부딪히게 됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;메시지 브로커들을 직접 관리해야 하므로 운영에 대한 부담이 늘어납니다.&lt;/li&gt;
  &lt;li&gt;대부분의 브로커가 스스로에 대한 모니터링 방법은 제공하지만 어떤 단말이 연결 중인지에 대한 정보까지는 제공해주지 않습니다.&lt;/li&gt;
  &lt;li&gt;서비스 안정성을 위해서 클러스터링 할 수 있어야 하지만 이것을 지원해주지 않는 브로커도 많습니다.&lt;/li&gt;
  &lt;li&gt;차량 제어라는 특수성을 만족하기에는 보안 측면에서 부족한 부분이 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그리하여 저희 팀에서는 직접 브로커를 관리 및 운영하기보다는, 클라우드 관리형 메시지 브로커 서비스인 &lt;a href=&quot;https://aws.amazon.com/ko/iot-core/&quot;&gt;AWS IoT Core&lt;/a&gt;를 사용하기로 하였습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;새-술은-새-부대에-aws-iot-core&quot;&gt;새 술은 새 부대에. AWS IoT Core.&lt;/h2&gt;

&lt;p&gt;AWS IoT Core를 쓰면 여러 이점을 얻을 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;관리되는 서비스이므로 운영에 있어 수기로 작업해줘야 하는 부분이 줄어듭니다.&lt;/li&gt;
  &lt;li&gt;IoT 단말들을 정책기반으로 운영할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;어떤 단말들이 연결되었는지 확인이 가능합니다.&lt;/li&gt;
  &lt;li&gt;메시지 브로커에 대한 모니터링 역시 손쉽게 가능합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/iot-pipeline-1/new_device_arch.jpg&quot; alt=&quot;&quot; width=&quot;75%&quot; height=&quot;75%&quot; style=&quot;display: block; margin: 0 auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;AWS IoT Core를 쓸 때 서비스를 운영하는 입장에서 가장 주요한 부분은 “관리되는 서비스”라는 점입니다. 카셰어링 서비스의 특성상 시간이나 시즌마다 데이터양이 크게 달라지는 이슈를 가지고 있습니다. 그리고 서비스에 부하가 걸리더라도 항상 단말은 명령 수신과 상태 보고에 있어 준비된 상태를 유지해야 합니다. 단말이나 통신 환경에 문제가 없을지라도 브로커의 상태가 불안정하면 서비스의 운영 안정성에 크게 영향을 미치므로 관리되는 서비스가 주는 이점은 강력하다 하겠습니다.&lt;/p&gt;

&lt;p&gt;특히나 AWS IoT Core를 사용하면서 강력한 도구가 되어주는 것이 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/iot/latest/developerguide/provision-wo-cert.html&quot;&gt;Fleet provisioning&lt;/a&gt;이라는 것입니다. 메시지 브로커에 인증받지 않은 단말이나 시스템이 접속하여 멋대로 메시지를 구독 혹은 발행하게 되면 보안 측면에서 데이터 유출이 일어나거나 차량 제어 측면에서 적절치 못한 제어를 통해 고객의 안전이 위협받을 수도 있습니다.&lt;/p&gt;

&lt;p&gt;따라서 메시지 브로커에 대한 접근 제한이 필수라 하겠는데, 수천 대가 넘어가는 단말들에 대해 일일히 접근 권한을 부여하고 관리하는 것도 큰일입니다. 이를 Fleet provisioning 기능을 통해 인증서와 보안정책 간의 결합을 통해 매우 편리하게 관리할 수 있게 되었습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;aws-iot-core-쓰면-끝&quot;&gt;AWS IoT Core 쓰면 끝?&lt;/h2&gt;

&lt;p&gt;AWS IoT Core를 활용하여 단순히 차량 데이터를 수집을 하는 것에만 머무르기엔 아쉽습니다. 여기서 더 나아가 각 부서(도메인)의 관점과 필요에 따라 수집된 데이터를 유연하게 활용한다면 더 좋을 것입니다. 기존에는 단말 데이터를 전부 DB에 저장하여 활용하는 방식을 사용했습니다. 그러나 이 방식은 DB 부하를 불러온다는 단점을 가지고 있습니다.&lt;/p&gt;

&lt;p&gt;모비딕 팀에서는 이 단점을 극복하기 위해 AWS IoT Core로부터 수집한 데이터를 &lt;a href=&quot;https://aws.amazon.com/ko/msk/&quot;&gt;Amazon MSK&lt;/a&gt;를 활용하여 흘려보내고 있습니다. 이러한 구조로 인해 데이터가 필요한 각 비즈니스 영역에서 MSK를 구독하는 컨슈머를 만들기만 하면 수집된 차량 상태 데이터를 활용할 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/iot-pipeline-1/aws_iot_arch.jpg&quot; alt=&quot;&quot; width=&quot;75%&quot; height=&quot;75%&quot; style=&quot;display: block; margin: 0 auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기까지 쏘카에서 사용 중인 단말들을 더 빠르게 제어하고 더 많은 데이터를 더 안정적으로 수집하기 위한 구조를 만들어 내는 과정을 설명해 드렸습니다.&lt;/p&gt;

&lt;p&gt;다음에는 실제 Amazon MSK를 구축할 때 마주쳤던 문제들을 해결하는 과정에서 얻어진 글로 찾아뵙겠습니다.&lt;/p&gt;</content><author><name>spock</name></author><category term="mobility" /><category term="iot" /><summary type="html">Photo by Mike Benna on Unsplash</summary></entry><entry><title type="html">쏘카 신입 데이터 엔지니어 디니의 4개월 회고</title><link href="https://tech.socarcorp.kr/data/2021/12/28/data-engineering-team-onboarding.html" rel="alternate" type="text/html" title="쏘카 신입 데이터 엔지니어 디니의 4개월 회고" /><published>2021-12-28T08:00:00+00:00</published><updated>2021-12-28T08:00:00+00:00</updated><id>https://tech.socarcorp.kr/data/2021/12/28/data-engineering-team-onboarding</id><content type="html" xml:base="https://tech.socarcorp.kr/data/2021/12/28/data-engineering-team-onboarding.html">&lt;p&gt;안녕하세요! 쏘카 데이터 엔지니어링 팀의 디니입니다.&lt;/p&gt;

&lt;p&gt;저는 2021년 8월에 쏘카 데이터 엔지니어링 팀에 신입 데이터 엔지니어로 입사했습니다. 지난 4개월간 데이터 엔지니어링 팀에서 경험하며 느낀 점을 공유하려 합니다. 그 중 데이터 엔지니어링 팀의 온보딩과 실무를 겪으며 느낀 내용을 주로 다루었습니다. 혹시 데이터 분석가나 데이터 사이언티스트의 내용이 궁금하신 분은 &lt;a href=&quot;https://tech.socarcorp.kr/data/2020/08/19/socar-data-group-intern-review.html&quot; target=&quot;_blank&quot;&gt;쏘카 데이터 그룹 - 데이터 사이언티스트 인턴 9개월 후기&lt;/a&gt;를 보시면 도움이 될 것 같습니다.&lt;/p&gt;

&lt;p&gt;다음과 같은 분들이 읽으시면 도움이 될 것 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쏘카 데이터 엔지니어링 팀의 신입 채용 과정이 궁금하신 분&lt;/li&gt;
  &lt;li&gt;쏘카 데이터 엔지니어링 팀에 입사한 인원이 빠르게 회사에 적응하기 위한 온보딩 과정이 궁금하신 분&lt;/li&gt;
  &lt;li&gt;온보딩 프로세스를 만들려고 하시는 분&lt;/li&gt;
  &lt;li&gt;쏘카 데이터 엔지니어링 팀이 어떻게 일을 하는지 관심 있으신 분&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;목차는 다음과 같습니다. 각 제목을 클릭하시면 해당 부분으로 이동하실 수 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;#join-process-and-background&quot;&gt;입사 지원 배경과 과정&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;지원 배경&lt;/li&gt;
      &lt;li&gt;입사 과정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#onboarding-process&quot;&gt;입사 후 온보딩 과정&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;온보딩 과제&lt;/li&gt;
      &lt;li&gt;과제 후 얻은 것&lt;/li&gt;
      &lt;li&gt;마무리 발표&lt;/li&gt;
      &lt;li&gt;그 외 온보딩 &amp;amp; 밍글링 과정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#after-onboarding&quot;&gt;온보딩 후 실무 투입 과정&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;첫 프로젝트 : 메타데이터 플랫폼 구축&lt;/li&gt;
      &lt;li&gt;각종 파티 참여&lt;/li&gt;
      &lt;li&gt;온보딩 과정이 어떻게 도움되었나요?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#throwback&quot;&gt;앞으로는 무엇을?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#qna&quot;&gt;Q &amp;amp; A&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-입사-지원-배경과-과정-&quot;&gt;1. 입사 지원 배경과 과정 &lt;a name=&quot;join-process-and-background&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;먼저 제가 회사를 지원하게 된 배경과 그 과정을 말씀드립니다.&lt;/p&gt;

&lt;h3 id=&quot;지원-배경&quot;&gt;지원 배경&lt;/h3&gt;

&lt;p&gt;저는 대학에서 경영학을 전공했고, 처음에는 데이터 분석에 관심이 있었습니다. 그런데 우연한 계기로 실시간 API의 데이터를 가공하여 데이터베이스에 적재하고 지표를 만드는 경험을 한 뒤, 데이터 엔지니어링의 매력을 느끼게 되었습니다.&lt;/p&gt;

&lt;p&gt;데이터 분석과 실험을 잘 하려면 원천(Raw) 데이터와 데이터 인프라 환경이 잘 만들어져야 하고, 이런 환경을 구축하는 것이 데이터 엔지니어링이라고 생각했습니다. 인프라, Database, 개발 등 다양한 경험을 할 수 있는 데이터 엔지니어가 멋있어(!) 보였고, 그렇게 저는 쏘카 데이터 엔지니어 포지션에 지원하게 되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;입사-과정&quot;&gt;입사 과정&lt;/h3&gt;

&lt;p&gt;쏘카 데이터 엔지니어링의 채용 프로세스는 다음처럼 진행되었습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;서류 제출&lt;/li&gt;
  &lt;li&gt;전화 면접&lt;/li&gt;
  &lt;li&gt;1차 면접(기술 면접)&lt;/li&gt;
  &lt;li&gt;2차 면접(임원 면접)&lt;/li&gt;
  &lt;li&gt;처우 협의&lt;/li&gt;
  &lt;li&gt;최종 합격&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;1-서류-제출&quot;&gt;1. 서류 제출&lt;/h4&gt;

&lt;p&gt;원티드를 통해 서류를 제출했습니다. 따로 자기소개서 양식은 없었고, 과거 프로젝트 경험이 담긴 이력서와 함께 &lt;a href=&quot;https://diana-lab.tistory.com/&quot; target=&quot;_blank&quot;&gt;개인 블로그&lt;/a&gt;와 &lt;a href=&quot;https://github.com/yoonhyejin&quot; target=&quot;_blank&quot;&gt;Github&lt;/a&gt;를 첨부했습니다.&lt;/p&gt;

&lt;h4 id=&quot;2-전화-면접&quot;&gt;2. 전화 면접&lt;/h4&gt;

&lt;p&gt;이력서에 있는 경험들과 데이터 엔지니어링에 대해 얼마나 알고 있는지를 중심으로 면접이 진행되었습니다. 업무 관련 문제 해결 경험, 관련 프레임워크를 써보거나 공부한 경험, DB 관련 개념은 알고 있는지 등의 질문이 있었습니다. 데이터 엔지니어링 팀장이신 토마스가 면접을 해주셨고 30분 정도 진행되었습니다.&lt;/p&gt;

&lt;h4 id=&quot;3-1차-면접-기술-면접&quot;&gt;3. 1차 면접 (기술 면접)&lt;/h4&gt;

&lt;p&gt;1차 기술 면접엔 포트폴리오 위주로 직무 관련 꼬리 질문이 이어졌습니다. 그 뒤에 코딩테스트가 있었는데, 총 3문제를 한 시간에 걸쳐 풀었습니다. 면접자에게 시간을 주고 풀게 한 뒤, 코드를 보면서 질문과 답변을 주고받는 형식이었습니다. 멀티 스레드, 클래스 등의 개념과 파이썬을 통한 로직 구현, SQL 쿼리의 여러 기능과 활용법을 알아야 하는 질문이 나왔습니다.&lt;/p&gt;

&lt;p&gt;이론적인 알고리즘 문제보다 현업에서 마주칠만한 문제 상황을 어떻게 코드로 해결할지를 묻는 질문이었습니다. 쏘카가 모빌리티 기업인 만큼, 모빌리티 관련 도메인 지식도 있으면 좋다 생각했습니다. &lt;strong&gt;정답 여부가 아닌 전체적으로 문제에 접근하는 논리를 보시는 것 같았습니다.&lt;/strong&gt; 개인적으로 모든 채용 과정 중 가장 긴장을 많이 한 과정이었습니다. 1시간 30분 정도 진행되었습니다.&lt;/p&gt;

&lt;h4 id=&quot;4-2차-면접-임원-면접&quot;&gt;4. 2차 면접 (임원 면접)&lt;/h4&gt;

&lt;p&gt;데이터 그룹의 그룹장이신 DK가 면접을 진행했습니다. 대부분 이력서 기반의 인성 질문들이었으나 기술 질문도 있었습니다. 회사에 대해 질문하는 Reverse Interview 과정도 20분 정도 있었습니다. 기술 면접에서 너무 긴장했던 탓인지 2차 면접은 상대적으로 순한맛(?)으로 느껴졌습니다.  1시간 정도 진행되었습니다.&lt;/p&gt;

&lt;p&gt;모든 과정의 결과 발표는 1주일 이내로 신속하게 진행되었고, 전화와 이메일을 통해 명확한 의사소통이 이루어졌습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2-입사-후-온보딩-과정-&quot;&gt;2. 입사 후 온보딩 과정 &lt;a name=&quot;onboarding-process&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;약 한 달 정도의 채용 프로세스 끝에 드디어 쏘카 데이터 엔지니어링 팀에 입사하게 되었습니다.&lt;/p&gt;

&lt;p&gt;쏘카 데이터 엔지니어링 팀은 총 8명으로 쏘카 데이터 엔지니어링 팀이 하는 일은 데이터 엔지니어링 팀의 하디가 작성한 &lt;a href=&quot;https://tech.socarcorp.kr/data/2021/03/24/what-socar-data-engineering-team-does.html&quot; target=&quot;_blank&quot;&gt;데이터 엔지니어링 팀이 하는 일&lt;/a&gt;과 &lt;a href=&quot;https://www.notion.so/socarcorp/d458b6b77a2243fb873d1ac800c321f7?p=1e895c6f8d6c49d0962d9c3af3e37f81&quot; target=&quot;_blank&quot;&gt;쏘카 데이터 엔지니어 채용공고&lt;/a&gt;에 잘 설명되어 있습니다.&lt;/p&gt;

&lt;p&gt;며칠 뒤, 2주 동안 4개의 온보딩 과제를 진행하게 되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;온보딩-과제&quot;&gt;온보딩 과제&lt;/h3&gt;

&lt;p&gt;이 온보딩 과제는 데이터 엔지니어링 팀에 가장 최근에 입사했던 그랩의 아이디어에서 출발했다고 합니다. 간단한 과제들을 통해 팀에서 다루는 도구와 업무 플로우에 익숙해지는 것이 목표였습니다. 과제를 통해 Kubernetes, Docker, Airflow, FastAPI, Git, Helm Chart와 같은 기술을 경험해볼 수 있었습니다. 구체적으로 과제 내용은 다음과 같았습니다.&lt;/p&gt;

&lt;h4 id=&quot;1-docker---docker-다루기&quot;&gt;1) Docker - Docker 다루기&lt;/h4&gt;

&lt;p&gt;첫 과제는 간단한 Docker 파일을 만들어 실행하고, Docker Compose로 Airflow를 띄워보는 내용이었습니다.&lt;/p&gt;

&lt;p&gt;데이터 엔지니어링 팀은 기본적으로 Kubernetes 환경에서 업무가 진행되기 때문에 Docker 부터 익혀야 한다는 생각으로 만들어진 과제입니다. 맨 처음에는 Docker를 설치하고, Ubuntu 컨테이너를 가져와서 실행하고 접속하여 파일을 만들어보는 등의 과정을 진행했습니다. 그다음에는 Ubuntu 이미지를 기반으로 hello world를 CMD를 이용해 출력하는 파일을 만들었습니다.&lt;/p&gt;

&lt;p&gt;이 뒤에는 Docker Compose를 이용해 Airflow를 띄우고 Web UI에 접속하는 것까지 진행했습니다. 이 과정에서 Airflow의 기본 구조도 공부할 수 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/data-engineering-onboarding/onboarding-comment.png&quot; alt=&quot;온보딩 과제 - 험프리 코멘트&quot; /&gt;
&lt;em&gt;Docker 과제 기록 - 천사 험프리의 코멘트&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-docker-compose--airflow---간단한-web-server-개발하기&quot;&gt;2) Docker Compose &amp;amp; Airflow - 간단한 Web Server 개발하기&lt;/h4&gt;

&lt;p&gt;여기서는 앞에서 배운 Docker Compose를 활용해 웹서버와 DB를 띄우고, 마찬가지로 Docker Compose로 Airflow를 띄운 뒤 웹서버와 통신하는 DAG을 작성하는 과제가 주어졌습니다.&lt;/p&gt;

&lt;p&gt;웹 프레임워크는 딱히 제한이 없어, 그나마 익숙했던 Flask로 간단한 웹서버를 만들었습니다. 그다음에 이 웹서버를 띄울 수 있는 Docker 파일을 만들어야 했습니다. 이 과정에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;ENTRYPOINT&lt;/code&gt; 와 &lt;code class=&quot;highlighter-rouge&quot;&gt;CMD&lt;/code&gt;의 사용법을 익히느라 헤맨 기억이 있습니다.&lt;/p&gt;

&lt;p&gt;그리고 DB를 위해 MySQL 컨테이너도 띄우고 (마찬가지로 제일 익숙한 것으로 했습니다.) Docker Compose를 통해 둘을 연결했습니다. 이후 Airflow를 따로 띄운뒤, 만든 웹서버에 HTTP Request를 하는 함수를 &lt;code class=&quot;highlighter-rouge&quot;&gt;PythonOperator&lt;/code&gt;로 호출하는 간단한 DAG을 작성했습니다. 여기서 “웹서버에 연결하려면 DAG에서 어떤 주소를 넣어줘야 하는가?”를 트러블슈팅하느라 많이 헤맸는데요. 팀원 험프리의 도움으로 결국 해결할 수 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/data-engineering-onboarding/onboarding-crying.png&quot; alt=&quot;온보딩 과제 - 트러블슈팅 과정&quot; /&gt;
&lt;em&gt;트러블슈팅 기록 - 중간중간 오열했습니다.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-airflow---간단한-dag-만들어서-실행하기&quot;&gt;3) Airflow - 간단한 DAG 만들어서 실행하기&lt;/h4&gt;

&lt;p&gt;이 과제는 &lt;code class=&quot;highlighter-rouge&quot;&gt;PythonOperator&lt;/code&gt;를 이용한 간단한 Airflow DAG을 만들고, 팀의 CI/CD 환경에 배포 및 실행해보는 내용이었습니다. 특정 기능을 구현하는 것보다 팀 업무 환경에 익숙해지기 위한 과제였습니다. 다른 과제보다 수월하게 진행할 수 있었습니다. 또한 저희팀 Git Repository에 다양한 샘플 DAG 코드가 업로드되어 있어서, DAG의 기본 구조 이해에 도움이 되었습니다.&lt;/p&gt;

&lt;p&gt;이 과제에서 생성한 DAG 안의 Task의 내용 자체는 매우 단순했지만 (print 문 등), 대신 Task 하나를 실행하거나 여러 Task를 병렬 처리하는 DAG를 생성해봤습니다.&lt;/p&gt;

&lt;h4 id=&quot;4-kubernetes---helm-chart를-작성하여-웹서버를-kubernetes에-배포하기&quot;&gt;4) Kubernetes - Helm chart를 작성하여 웹서버를 Kubernetes에 배포하기&lt;/h4&gt;

&lt;p&gt;이 과제는 간단한 API 서버를 구축하고 Docker로 빌드하여 GCR(Google Container Registry)에 이미지로 Push한 뒤, Helm Chart를 작성하여 이 이미지를 GKE(Google Kubernetes Engine)에 배포하는 과정이었습니다. Helm Chart 기능들을 배우면서 팀 환경에도 익숙해지기 위한 과제였습니다.&lt;/p&gt;

&lt;p&gt;이 과제에서도 웹 프레임워크는 딱히 정해지지 않았지만, 팀에서 FastAPI를 자주 쓰고 있었기 때문에 겸사겸사해서 FastAPI로 웹서버를 구현했습니다. (이 과정에서 저만의 셀프 FastAPI 온보딩 과제- 간단한 CRUD 서버 구축해보기도 있었습니다.)&lt;/p&gt;

&lt;p&gt;Helm Chart를 직접 만들고 &lt;code class=&quot;highlighter-rouge&quot;&gt;values.yaml&lt;/code&gt; 을 작성하는 방법, GKE 환경을 설정하는 방법 등 짧은 시간에 많은 걸 접하고 배울 수 있었습니다. 처음에는 Kubernetes의 개념을 익히기 위해 minikube 로 테스트를 해봤고, 나중엔 팀 GKE에서 실습했습니다. 회사 GKE에서만 할 수 있는 설정들(GCR에 있는 이미지 Pull, Ingress 할당 등)이 있어서 조금 헤맸던 기억이 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;과제-후-얻은-것&quot;&gt;과제 후 얻은 것&lt;/h3&gt;

&lt;p&gt;이렇게 4개의 온보딩 과제를 완료하는데 총 2주가 걸렸습니다. 신입 입장에서 이렇게 전체적으로 업무의 흐름을 파악하는 시간이 주어진 게 정말 감사한 일이었습니다. 👍&lt;/p&gt;

&lt;p&gt;모든 회사에서 이런 기회가 주어지지 않는다는 것을 알기에 더욱 소중한 시간이었습니다.&lt;/p&gt;

&lt;p&gt;가장 큰 장점은 &lt;strong&gt;“업무 적응에 대한 심적 부담이 크게 줄었다!”&lt;/strong&gt;입니다. 사실 데이터 엔지니어링 팀에 필요한 도메인이 매우 넓은데, 관련 경험이 거의 없어서 처음에 막연한 두려움이 있었습니다. 그런데 Task 자체는 매우 단순화한 상태에서 프레임워크를 사용해보고 플로우를 익혀보니, 좀 더 복잡한 업무도 “아, 일단 이건 해봤으니까 여기서 발전해나가면 되겠구나!” 하는 자신감이 생겼습니다.&lt;/p&gt;

&lt;p&gt;첫 환경 세팅이나 배포의 난관을 온보딩 과제를 통해 극복할 수 있던 것도 큰 의미가 있었습니다. 프레임워크뿐만 아니라 &lt;a href=&quot;https://k8slens.dev/&quot; target=&quot;_blank&quot;&gt;Lens&lt;/a&gt; 등 팀에서 활용하고 있는 모니터링 도구도 이때 빨리 접할 수 있었습니다. 팀 문서나 코드도 점점 눈에 들어오기 시작했습니다. 그리고 트러블슈팅 과정을 기록한 것들을 공유하며, 제가 어떤 부분에서 부족한지 팀원들의 피드백을 받아볼 수 있어서 좋았습니다.&lt;/p&gt;

&lt;h3 id=&quot;마무리-발표&quot;&gt;마무리 발표&lt;/h3&gt;

&lt;p&gt;이렇게 2주 동안 과제를 수행한 뒤, 온보딩 과제를 회고하는 발표를 하게 되었습니다. 주로 온보딩 과제와 트러블 슈팅 내용들, 제가 느꼈던 감정들 위주였습니다. 발표 후, 이런 식으로 온보딩 과정을 발전 및 정착시켰으면 좋겠다는 논의도 나왔습니다. 앞으로 더 개선된 온보딩 과정이 기대됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/data-engineering-onboarding/onboarding-pitch-airflow.png&quot; alt=&quot;온보딩 발표 중 Airflow&quot; /&gt;
&lt;em&gt;트러블슈팅 과정 설명&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/data-engineering-onboarding/onboarding-pitch-graph.png&quot; alt=&quot;과제에 따른 감정 변화&quot; /&gt;
&lt;em&gt;과제에 따른 감정 변화&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;그-외-온보딩--밍글링-과정&quot;&gt;그 외 온보딩 &amp;amp; 밍글링 과정&lt;/h3&gt;
&lt;p&gt;이런 온보딩 과제 외에도 쏘카에서는 다양한 방법으로 적응을 도와주는 아래와 같은 과정이 있습니다. 이런 과정들을 통해 쏘카 데이터 그룹 팀원들과 좀 더 친해지고, 빨리 적응할 수 있었습니다.&lt;/p&gt;

&lt;h4 id=&quot;1-각종-온보딩-세션&quot;&gt;1) 각종 온보딩 세션&lt;/h4&gt;
&lt;p&gt;회사 차원에서 PX(People Experience)팀에서 하루 정도 시간을 잡고 쏘카 회사의 히스토리와 문화에 대해서 알려주는 온보딩 과정이 있었습니다. 또한 PX팀과 따로 1:1 로 티타임을 하고, 온보딩 과정에 대한 만족도 조사를 하는 등 신규 입사자를 세심하게 신경 써주는 느낌을 받았습니다.  데이터 그룹 단위에서는 팀장인 토마스가 3번에 걸쳐 1:1로 한 시간씩 쏘카 데이터 그룹의 인프라와 히스토리를 설명해주는 시간이 있었습니다.&lt;/p&gt;

&lt;h4 id=&quot;2-라이브-슬랙&quot;&gt;2) 라이브 슬랙&lt;/h4&gt;

&lt;p&gt;라이브 슬랙은 데이터 그룹엔 신규 입사자가 자기를 소개하는 PPT를 한 장으로 만들어 슬랙(업무용 메신저)에 올리면, 데이터 그룹 전체가 질문하고 신규 입사자는 15분 동안 열심히 답변하는 이벤트입니다. 순발력과 빠른 타자 실력이 요구되었습니다. 참고로 이 문화는 VCNC에서 진행하는 라이브 슬랙을 참고했다고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/data-engineering-onboarding/live-slack.png&quot; alt=&quot;하디의 레전드 질문&quot; /&gt;
&lt;em&gt;인상 깊었던 하디의 레전드 질문&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-해피아워&quot;&gt;3) 해피아워&lt;/h4&gt;

&lt;p&gt;데이터 그룹은 한 달에 한 번 금요일 오후에 해피아워를 진행합니다. 해피아워는 다양한 데이터 그룹의 사람들이 서로 친해지며 휴식하는 시간입니다. 코로나가 심하지 않을 때는 영화를 보거나 맥주를 마시러 가기도 했다고 합니다. 코로나 시국에는 비대면으로 마피아게임, 캐치마인드, 몸으로 말해요 등 여러 액티비티를 경험했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/data-engineering-onboarding/happy-hour.png&quot; alt=&quot;해피아워 공지&quot; /&gt;
&lt;em&gt;지금은 제가 해피아워 공지를 올립니다.&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;3-실무-투입-과정-&quot;&gt;3. 실무 투입 과정 &lt;a name=&quot;after-onboarding&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;이렇게 온보딩 과제를 마무리한 후에도 조금씩 업무에 투입되었습니다. 이 기간에 팀원 그랩이 추천해준 &lt;a href=&quot;http://www.yes24.com/Product/Goods/89607047&quot; target=&quot;_blank&quot;&gt;“Kubernetes in Action”&lt;/a&gt;이라는 책을 읽으며 정리했습니다.&lt;/p&gt;

&lt;h3 id=&quot;첫-프로젝트--메타데이터-플랫폼-구축&quot;&gt;첫 프로젝트 : 메타데이터 플랫폼 구축&lt;/h3&gt;

&lt;p&gt;입사 후 처음 맡게 된 프로젝트입니다. 쏘카에선 개발 직군, 비개발 직군 상관없이 많은 분들이 데이터를 적극적으로 이용하고 있습니다. 점점 더 데이터가 복잡해지고 이용자가 늘어나는 상황에서 “어떤 데이터가 어디에 있는지”, “특정 테이블 혹은 칼럼은 어떤 정보를 담고 있는지”, 즉 메타데이터를 쉽게 파악하는 일이 중요해졌습니다.&lt;/p&gt;

&lt;p&gt;이런 메타데이터의 효율적 관리를 위한 “전사적 메타데이터 플랫폼”을 도입하는 과정에 카일과 함께 참여하게 되었습니다. 현재는 &lt;a href=&quot;https://github.com/linkedin/datahub&quot; target=&quot;_blank&quot;&gt;Datahub&lt;/a&gt;라는 프레임워크를 선택하여 GKE에서 테스트 과정 중에 있으며, 추후 전사 플랫폼으로 도입할 예정입니다. 기획 단계부터 리서치, 테스트와 배포와 커스텀 기능 개발까지 경험할 수 있어서 정말 재밌게 하고 있습니다.&lt;/p&gt;

&lt;p&gt;구체적으로는 다음과 같은 일들을 해볼 수 있었습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Data Ingestion 과정을 Docker 이미지로 만들고 Airflow DAG에 연동하여 스케줄링하기&lt;/li&gt;
  &lt;li&gt;Ingestion을 수행하는 계정 권한을 최소화하기 위해 자체 메타데이터 추출 로직 개발하기&lt;/li&gt;
  &lt;li&gt;Helm Chart, ArgoCD를 이용하여 GKE에 배포하기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;아래는 Datahub 공식 사이트에서 제공하는 &lt;a href=&quot;https://demo.datahubproject.io/&quot; target=&quot;_blank&quot;&gt;데모 사이트&lt;/a&gt;의 스크린샷입니다. 이 플랫폼이 완성되면 또 다른 글로 찾아오겠습니다 :)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/data-engineering-onboarding/datahub-demo-main.png&quot; alt=&quot;Datahub 데모 메인 스크린샷&quot; /&gt;
&lt;em&gt;Datahub - 데모 메인 페이지.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/data-engineering-onboarding/datahub-demo-bigquery.png&quot; alt=&quot;Datahub 데모 빅쿼리 스크린샷&quot; /&gt;
&lt;em&gt;Datahub - 데모 상세 페이지.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;각종-파티-참여&quot;&gt;각종 파티 참여&lt;/h3&gt;

&lt;p&gt;“파티”는 데이터 엔지니어링 팀에서 도입한 업무 형태입니다. 쉽게 말해 “중장기 프로젝트”라고 보시면 됩니다.&lt;/p&gt;

&lt;p&gt;데이터 엔지니어링 팀에서 해결해야 하는 문제를 파티의 주제로 선정하고, 관련된 사람들이나 혹은 해당 주제에 관심 있는 사람들을 모아 킥오프를 합니다. 파티의 리더인 파티장은 팀원 중 한 명이 맡게 되며, 파티장을 돌아가면서 할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;파티는 여러 “시즌”이 있고, 한 시즌 안에는 여러 “액트(Act)”가 있습니다. 각자의 업무와 시간, 우선순위 등을 고려하여 필요한 일감을 시즌과 액트로 나누고 파티원들에게 일감을 분배합니다. 그리고 정기 회의를 통해 진행 상황을 리뷰하고 한 액트 혹은 시즌이 끝나면 회고하는 시간을 가집니다.&lt;/p&gt;

&lt;p&gt;현재 데이터 엔지니어링 팀에서 진행하는 파티는 로그 시스템, 가격 시스템, 데이터 마트 등 여러 분야가 있습니다.&lt;br /&gt;
제가 현재 참여하고 있는 파티는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;소다 스토어 파티&lt;/strong&gt; - 쏘카의 데이터를 깔끔하고 편리하게&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;소다 스토어는 쏘카의 데이터를 한눈에 볼 수 있는 데이터 마트입니다. 자세한 설명은 &lt;a href=&quot;https://tech.socarcorp.kr/data/2021/03/24/what-socar-data-engineering-team-does.html&quot; target=&quot;_blank&quot;&gt;쏘카 데이터 그룹 - 데이터 엔지니어링 팀이 하는 일&lt;/a&gt;에서 볼 수 있습니다.&lt;/li&gt;
  &lt;li&gt;이 파티에서 쿼리의 확장성과 모듈화를 위해 &lt;a href=&quot;https://www.getdbt.com/&quot; target=&quot;_blank&quot;&gt;dbt&lt;/a&gt;라는 도구를 소다 스토어와 관련된 쿼리에 적용하는 작업을 하고 있습니다.&lt;/li&gt;
  &lt;li&gt;또한 dbt를 적용하는 대부분의 과정을 자동화하는 CLI를 만드는 과정에 참여하고 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/data-engineering-onboarding/shamanism-engineering.png&quot; alt=&quot;샤머니즘 엔지니어링&quot; /&gt;
&lt;em&gt;페어코딩 중 코드가 돌아가길 기도하고 있는 모습&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;소다 로그 파티&lt;/strong&gt; - 쏘카의 모든 로그를 효율적으로 관리한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쏘카의 모든 로그를 잘 가공하여 사용자가 잘 사용할 수 있도록 만드는 파티입니다.&lt;/li&gt;
  &lt;li&gt;이 파티에서 기존 레거시 서버에 있는 로그 적재용 Airflow DAG들을 Kubernetes 환경으로 안전하게 옮기는 일을 하고 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;온보딩-과정이-어떻게-도움-되었나요&quot;&gt;온보딩 과정이 어떻게 도움 되었나요?&lt;/h3&gt;

&lt;p&gt;메타데이터 프로젝트에선 플랫폼에 메타데이터 주입 과정을 커스텀화 하기 위해서 Docker Image를 직접 빌드해야 했습니다. 온보딩 과제에서 Docker Image를 만들고 관련 명령어를 다뤄본 경험을 활용할 수 있었습니다. 그리고 이렇게 만든 Docker Image를 Airflow의 &lt;code class=&quot;highlighter-rouge&quot;&gt;KubernetesPodOperator&lt;/code&gt;로 실행해 배포하는 과정도 필요했습니다. 이 과정 역시 온보딩 과제 중 간단한 Airflow DAG을 만들고 배포해본 경험에서 응용할 수 있었습니다.&lt;/p&gt;

&lt;p&gt;또한 Datahub를 Helm chart를 이용하여 GKE에 배포해야 했습니다. 이 역시 온보딩 과제에서 Helm Chart로 GKE로 배포해보았던 경험이 도움 되었습니다. 물론 온보딩 때보다 Datahub의 차트가 훨씬 복잡했지만, 기본적인 플로우를 이해하고 있는 것이 큰 도움이 되었습니다.&lt;/p&gt;

&lt;p&gt;소다 로그 파티에서는 기존 레거시 서버에서 쿠버네티스로 DAG을 옮기는 과정에서, Airflow DAG의 설정을 수정하고 GitHub Repository를 통해 DAG을 CI/CD 파이프라인으로 배포해야 했습니다. 이 과정에서도 Airflow 관련 온보딩 경험을 다시 한번 활용할 수 있었습니다.&lt;/p&gt;

&lt;p&gt;결과적으로, 초기 업무를 할 때 온보딩 과제를 정리한 글을 20번 넘게 스스로 참고할 정도로 실질적인 도움이 되었습니다. 이렇게 보니 온보딩 과정이 없으면 정말 큰일 날뻔했네요 😂&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;4-앞으로는-무엇을-&quot;&gt;4. 앞으로는 무엇을? &lt;a name=&quot;throwback&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;많은 분의 도움이 있었던 온보딩 기간을 거치고, 앞으로 회사에서 하고 싶은 것이 생겼습니다.&lt;/p&gt;

&lt;h3 id=&quot;여러-사람이-편해지는-시스템이나-도구를-만들고-싶어요&quot;&gt;여러 사람이 편해지는 시스템이나 도구를 만들고 싶어요.&lt;/h3&gt;

&lt;p&gt;데이터 엔지니어링 업무 자체가 서포팅의 성격이 있습니다. 회사에서 저뿐만이 아니라 여러 사람이 편해지는 시스템이나 도구를 만들고 싶습니다.&lt;br /&gt;
예를 들면 “디니의 트러블슈팅 DB”를 만들고 있는데요. 지금 트러블슈팅한 과정을 미래의 나 혹은 다른 사람이 구글링처럼 편하게 검색하고 찾을 수 있었으면 좋겠다는 생각에서 시작되었습니다.&lt;/p&gt;

&lt;p&gt;그리고 제가 온보딩 과정에서 도움을 많이 받은 만큼 다음 오시는 분을 위해 온보딩 과정을 더욱 발전시키고 싶습니다. 개인적인 경험으로는 ArgoCD를 통한 배포와, Python 협업 환경(테스트 코드 짜기, 디버깅 하기 등)에 대한 온보딩 등이 추가되면 더 좋겠다고 느꼈습니다.&lt;/p&gt;

&lt;h3 id=&quot;문화-개선에-기여하고-싶어요&quot;&gt;문화 개선에 기여하고 싶어요.&lt;/h3&gt;

&lt;p&gt;함께 일하기 즐거운 회사가 되면 좋겠다는 소망이 있고, 제가 할 수 있는 것부터 하려고 노력 중입니다.
예를 들면 데이터 그룹 해피아워, 워크샵 등 밍글링 행사의 기획을 맡고 있고, “코딩 안풀릴때 소리지르는 방” 슬랙 채널 개설해서 다들 일하다 마음껏 소리지르는 (…) 공간을 만들었어요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/data-engineering-onboarding/screaming.png&quot; alt=&quot;코딩 안될때 소리지르는 짤&quot; /&gt;
&lt;em&gt;입사 이후 최대의 업적 : 코딩 안될때 소리지르는 방 만든 것.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;많이-공유하고-싶어요&quot;&gt;많이 공유하고 싶어요.&lt;/h3&gt;

&lt;p&gt;취업 준비 할 때 쏘카 기술 블로그를 많이 참고하기도 했고 공부하면서 언제나 다른 사람의 글을 보며 배우고 있기 때문에, 항상 유용한 글을 쓰고 싶다는 마음이 있습니다. 곧 메타데이터 플랫폼 글로 돌아오겠습니다. 😏&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;5-q--a-&quot;&gt;5. Q &amp;amp; A &lt;a name=&quot;qna&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;마지막으로 취업을 준비하면서 스스로 궁금했던, 그리고 비슷한 과정에 계실 분들이 궁금할만한 질문들과 이에 대한 답변을 정리해보았습니다.&lt;/p&gt;

&lt;h3 id=&quot;실무에서-데이터-분석가데이터-사이언티스트와-데이터-엔지니어의-차이는&quot;&gt;실무에서 데이터 분석가(데이터 사이언티스트)와 데이터 엔지니어의 차이는?&lt;/h3&gt;

&lt;p&gt;데이터 분석가와 데이터 사이언티스트 분들이 맘껏 능력 발휘할 수 있는 탄탄한 플레이그라운드를 만드는 것이 데이터 엔지니어링의 역할인 것 같습니다. 취업 준비할 때는 데이터 관련 직군 간의 업무 차이가 잘 와닿지 않았는데, 실무를 경험해보니 담당하는 업무가 확연히 다른 것 같습니다. (물론 회사마다 정의가 다르고, 작은 규모에서는 같이 하시는 분들도 있을 것 같습니다)&lt;/p&gt;

&lt;p&gt;아주 단순하게 얘기하자면 데이터 분석가는 말 그대로 ‘분석가’, 데이터 엔지니어는 ‘개발자’의 모습에 가깝다고 생각합니다. 어떤 목적을 해결하기 위해 데이터를 통해 분석하거나 사업적인 고민하는 것이 좋다면 데이터 분석을, 시스템 구축과 자동화, 프로그래밍 자체에 관심이 많다면 데이터 엔지니어링이 더 맞지 않을까 싶습니다.&lt;/p&gt;

&lt;h3 id=&quot;비전공자-문과라는-백그라운드가-회사에서-어떻게-작용하는지&quot;&gt;비전공자, 문과라는 백그라운드가 회사에서 어떻게 작용하는지?&lt;/h3&gt;

&lt;p&gt;저도 이 점에 대해서 걱정했는데, 저희 팀에는 오히려 비전공자가 더 많고 중요한 건 아무도 과(와 학교)에 신경을 쓰지 않습니다. 그런 백그라운드보다 요구하는 일을 할 수 있는 실력이 더 중요하다고 느꼈습니다.&lt;/p&gt;

&lt;p&gt;그리고 커뮤니케이션 능력은 어디서 무슨 일을 하든 무조건 플러스라고 생각합니다. 회사에 와서 보니 의사결정, 우선순위 산정 등 다른 게 더 중요할 수도 있다는 생각이 들었습니다. &lt;a href=&quot;https://eoeoeo.net/2021/08/12/%EB%B0%B0%EB%8B%AC%EC%9D%98%EB%AF%BC%EC%A1%B1-ceo%EA%B0%80-%EB%A7%90%ED%95%98%EB%8A%94-%ED%95%A8%EA%BB%98-%EC%9D%BC%ED%95%98%EA%B3%A0-%EC%8B%B6%EC%9D%80-%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98-%EA%B8%B0/&quot; target=&quot;_blank&quot;&gt;배달의 민족 CEO 인터뷰&lt;/a&gt;에서 “개발자는 비즈니스 문제를 해결하는 사람”으로 정의하길 바란다는 말씀을 합니다. 이와 같이 코딩 뿐만 아니라 문제 해결에 지치지 않고 재밌어한다면 개발자가 잘 맞을 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;신입-데이터-엔지니어를-희망한다면-어떻게-포트폴리오를-꾸리면-좋을까&quot;&gt;신입 데이터 엔지니어를 희망한다면 어떻게 포트폴리오를 꾸리면 좋을까?&lt;/h3&gt;

&lt;p&gt;개인적으로는 데이터 엔지니어링이 참 포트폴리오를 준비하기 힘든 분야라고 느꼈습니다. 소소하지만 저의 팁을 공유합니다.&lt;/p&gt;

&lt;h4 id=&quot;1-가고-싶은-회사가-어떤-환경인지-보고-공부하자&quot;&gt;1) 가고 싶은 회사가 어떤 환경인지 보고 공부하자.&lt;/h4&gt;

&lt;p&gt;가고 싶은 회사의 채용공고를 꼼꼼히 읽고, 어떤 툴과 프레임워크를 쓰는지 보시면서 그 프레임워크에 대한 공부를 하시면 좋을 것 같습니다&lt;/p&gt;

&lt;p&gt;저희가 알고 있는 IT 기업들은 AWS, GCP, Hadoop 이 선에서 크게 달라지지 않는다고 생각합니다. 온라인 강의 사이트에서 이런 프레임워크를 타겟으로 한 강의를 참고하시면 좋을 것 같습니다.&lt;/p&gt;

&lt;p&gt;쏘카 데이터 그룹은 기본적으로 GCP(Google Cloud Platform)를 이용하고 있기 때문에, 개인적으로 &lt;a href=&quot;https://www.qwiklabs.com/&quot; target=&quot;_blank&quot;&gt;Qwiklabs&lt;/a&gt; 플랫폼의 GCP 관련 실습 강의(ex.&lt;a href=&quot;https://www.qwiklabs.com/quests/132&quot; target=&quot;_blank&quot;&gt;Engineer Data in Google Cloud&lt;/a&gt;)가 많은 도움되었습니다. Hadoop의 경우 조금 오래된 강의지만 &lt;a href=&quot;https://www.udemy.com/&quot; target=&quot;_blank&quot;&gt;Udemy&lt;/a&gt; 플랫폼의 &lt;a href=&quot;https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/&quot; target=&quot;_blank&quot;&gt;The Ultimate Hands-On Hadoop&lt;/a&gt; 강의를 통해 기본 개념을 익힐 수 있었던 기억이 납니다. 이 외에도 &lt;a href=&quot;https://www.udacity.com/&quot; target=&quot;_blank&quot;&gt;Udacity&lt;/a&gt;, &lt;a href=&quot;https://www.oreilly.com/&quot; target=&quot;_blank&quot;&gt;O’Reilly&lt;/a&gt; 등의 강의 플랫폼에서 유용한 강의들을 찾으실 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;2-나만의-작고-귀여운-etl-파이프라인을-만들어보자&quot;&gt;2) 나만의 작고 귀여운 ETL 파이프라인을 만들어보자.&lt;/h4&gt;

&lt;p&gt;데이터 엔지니어링 분야에서 가장 무난하게 포트폴리오를 만들 수 있는 것은 ETL 파이프라인이라고 생각합니다. 꼭 가고 싶은 회사의 프레임워크와 일치하지 않아도 상관없으니, 관심 있는 API 데이터를 ETL 하는 파이프라인을 만들어보면 관련된 아이디어를 발전시킬 수 있을 거라 생각합니다.&lt;/p&gt;

&lt;h4 id=&quot;3-블로그를-잘-관리하자&quot;&gt;3) 블로그를 잘 관리하자.&lt;/h4&gt;

&lt;p&gt;신입 입장에서 이력서로 엄청난 차이를 보여주기는 쉽지 않다고 생각합니다. 이럴 때, 본인을 설명해줄 수 있는 개인 블로그나 포트폴리오 사이트가 있으면 좋습니다. 글이 완벽하지 않더라도 공부한 것들이나 관심있는 내용을 작성하면 좋은 것 같습니다.&lt;/p&gt;

&lt;p&gt;여기까지 데이터 엔지니어링팀 디니의 4개월 신입 회고였습니다.  온보딩 과정을 도와주신 팀원분들 이 자리를 빌어 다시 한번 감사드립니다.&lt;br /&gt;
긴 글 읽어주셔서 감사합니다. 궁금한 점이 있으시면 언제든 댓글 남겨주세요 :)&lt;/p&gt;</content><author><name>dini</name></author><category term="data" /><category term="data" /><category term="data-engineering" /><summary type="html">안녕하세요! 쏘카 데이터 엔지니어링 팀의 디니입니다.</summary></entry><entry><title type="html">수요일엔 수요미식회, 금요일은 개발밋업회</title><link href="https://tech.socarcorp.kr/dev/2021/11/01/socar-developer-meetup.html" rel="alternate" type="text/html" title="수요일엔 수요미식회, 금요일은 개발밋업회" /><published>2021-11-01T00:00:00+00:00</published><updated>2021-11-01T00:00:00+00:00</updated><id>https://tech.socarcorp.kr/dev/2021/11/01/socar-developer-meetup</id><content type="html" xml:base="https://tech.socarcorp.kr/dev/2021/11/01/socar-developer-meetup.html">&lt;div class=&quot;photo-copyright&quot;&gt;
Photo by DaeHyun Kim
&lt;/div&gt;

&lt;p&gt;안녕하세요. 모빌리티 시스템 그룹 - 모비딕 팀의 스팍입니다.&lt;br /&gt;
쏘카에서 최근에 진행한 밋업회에 대한 내용을 이 글에서 공유해봅니다.&lt;/p&gt;

&lt;h2 id=&quot;회사가-10년이-되었습니다&quot;&gt;회사가 10년이 되었습니다.&lt;/h2&gt;

&lt;p&gt;저는 쏘카의 초창기 멤버라고 말할 수는 있어도 창립 멤버는 아닙니다. 쏘카가 제주에서 시작한 지 2년 정도 지나 서울로 진출을 시작했을 때 합류했습니다.&lt;/p&gt;

&lt;p&gt;다만 운 좋게도 쏘카의 고속 성장 직전에 합류할 수 있었습니다. 제가 입사할 때만 하더라도 개발자는 저 포함 고작 네 명이었습니다. 회의를 진행하기 매우 편한 환경이였습니다. 그냥 그 자리에서 뒤로 돌아앉기만 하면 그만이었거든요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/socar-dev-meetup/20131226_112006.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이랬던 조직이 회사의 성장 속도에 따라 급작스레 커지면서 점점 고민이 생기게 됩니다.&lt;/p&gt;

&lt;p&gt;그중에 가장 고민인 부분은 &lt;strong&gt;사람들 사이의 거리가 멀어지는 것&lt;/strong&gt; 입니다. 이 고민은 문제가 있어 발생하는 것이 아니라 조직이 커지다 보니 자연스레 발생하는 일입니다. 저 위의 사진에 있는 사람들이 조직이 커지면서 각각 프론트팀, 백엔드팀, 인프라팀 등으로 나뉘었다고 생각하면 됩니다.&lt;/p&gt;

&lt;p&gt;그리고 다음과 같은 고민이 추가적으로 생기기 시작합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;조직이 분화와 더불어 개인의 성향을 어떻게 고려할 수 있을까? 쉽게 표현하자면, 건물의 대들보, 기둥, 서까래들이 한곳에 모여있을 땐 괜찮았지만, 각각 흩어져서 새로운 집의 자재가 되려 하니 필요로 하는 특성을 발휘하지 못하는 경우가 발생합니다.&lt;/li&gt;
  &lt;li&gt;성장에 초점이 맞춰져 있는 스타트업의 경우, 급속한 성장의 흐름을 타기 시작하면 일반적인 개발 조직에서 챙겨야 할 것들을 놓칠 수 있습니다. 대표적인 것이 문서화인데, 다 챙기려는 노력을 하지만 문서가 누락이 되는 경우가 존재합니다. 특정 부분의 히스토리가 잘 남지 않는 문제가 발생합니다. 많은 회사에서 경험할 수 있는 상황입니다.&lt;/li&gt;
  &lt;li&gt;급속도로 조직이 성장하다 보니, 회사도 조직의 “구심점”이 되어주는 사람을 어떻게 키울지 고민하게 됩니다. 물론 회사의 각 조직장을 담당하는 분들이 구심점 역할을 하지만, 조직이 점점 커지면서 다양한 역할을 세분화할 필요가 있습니다. 한 조직에는 분위기 메이커도 필요하고 멘토도 필요합니다. 마치 연극처럼 각자의 역할을 맡아주는 사람들이 필요한 것이죠. 이런 사람들이 많으면 많을수록 조직의 생동감이 늘어난다고 봅니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그리하여, 이러한 문제들을 해결하기 위한 시도로 쏘카 내에서 개발밋업회를 만들어 보기로 했습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;밋업회-그거-개발자-세미나-같은-것-아닌가&quot;&gt;밋업회? 그거 개발자 세미나 같은 것 아닌가?&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/socar-dev-meetup/neonbrand-1-aA2Fadydc-unsplash.jpg&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;Photo by &lt;a href=&quot;https://unsplash.com/@neonbrand&quot;&gt;NeONBRAND&lt;/a&gt; on &lt;a href=&quot;https://unsplash.com/s/photos/meetup&quot;&gt;Unsplash&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;틀린 말은 아닙니다. 실제로 많은 개발자 밋업이 기술 교류와 세미나로 이루어지고 있습니다. 그리고 이런 문화의 원류를 찾아 거슬러 올라가 보면 &lt;a href=&quot;https://en.wikipedia.org/wiki/Homebrew_Computer_Club&quot;&gt;HomeBrew Compute Club&lt;/a&gt;을 만나게 됩니다. 그리고 우리가 다들 아는 이바닥의 구루이자 전설 아닌 레전드들이 왕년에 저 멤버로 참여하셨죠. 그러한 대표적인 예로 스티브 워즈니악이 있습니다.&lt;/p&gt;

&lt;p&gt;주목할 것은 저 그룹은 해커들의 취미생활이자 소셜 네트워크의 기능을 했다는 것입니다. 서로의 지식을 공유하고 취미로 같이 프로젝트 할 사람 모아보고 했던 그룹이라는 거죠.&lt;br /&gt;
그렇게 놓고 보니 왠지 급속도로 확장된 조직을 급한 대로 붙여주는데에는 괜찮은 딱풀 역할을 할 만한 접근법이라는 생각이 들었습니다.&lt;br /&gt;
그리고 스타트업의 정신이라 하면 &lt;strong&gt;일단 시작하고 본다!&lt;/strong&gt; 아니겠습니까?&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;그래서-어떻게-준비했나요&quot;&gt;그래서 어떻게 준비했나요?&lt;/h2&gt;

&lt;p&gt;참고할 자료를 찾기 위해  여기저기 검색한 결과, “밋업 참관 후기”는 많지만 “밋업을 이렇게 준비했습니다” 하는 내용은 적었습니다. 하지만 그렇다고 해서 포기하기엔 &lt;del&gt;쏘카 짬밥 7년이&lt;/del&gt; 너무나 아쉬운 관계로 하나씩 만들어보기로 했습니다.&lt;/p&gt;

&lt;p&gt;이런 모임을 만들 때 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%A7%88%EA%B7%B8%EB%82%98_%EC%B9%B4%EB%A5%B4%ED%83%80&quot;&gt;대헌장&lt;/a&gt;이 중요한 역할을 해줄 것이라 생각해서, 나름의 다음과 같은 원칙과 목표를 세웠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;참석도 쉽고 불참도 쉬워야 합니다. 밋업회 자체가 업무처럼 되어서는 안 된다고 생각했습니다.&lt;/li&gt;
  &lt;li&gt;서로 조직이 달라도 업무로 인해 모였을 때 필요한 아이스 브레이킹을 밋업회로 해소할 수 있어야겠죠.&lt;/li&gt;
  &lt;li&gt;개발자들이 편하게 이야기 할 수 있도록 했습니다. 아무리 쏘카가 수평적인 조직이라 하더라도 대한민국이 동방예의지국인 이상 쉽게 이야기하기 어려운 부분도 있을 것입니다. 그러한 부분도 덜어주고 싶었습니다.&lt;/li&gt;
  &lt;li&gt;지식과 경험을 최대한 공유할 수 있어야 합니다. 회사의 히스토리가 구전문학처럼 전해져 내려가는 것은 문제가 있지만 그렇다고 해서 그게 아예 사라져버리는 것은 더 큰 문제가 됩니다.&lt;/li&gt;
  &lt;li&gt;안 그래도 구전문학이 문제가 되는데 밋업회마저 구전될 수는 없겠죠. 매회 나누었던 이야기들을 작게라도 기록해 나 갈수 있도록 했습니다.&lt;/li&gt;
  &lt;li&gt;팀별로 서로 간의 사정 파악을 할 수 있어야 합니다. 사람인 이상 일하는데 마찰이 아예 없을 수는 없습니다. 그것을 쌓아만 놓기보다는 업무가 아닌 자리에서 허심탄회하게 털어버릴 수 있도록 하고 싶었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위와 같은 목표를 기반으로 해서, 밋업회에서 이야기해보고 싶은 주제를 매주 제가 제시하거나 참석자들에 받아 자유롭게 생각을 나누는 방식으로 진행을 하였습니다. 일종의 오픈토론처럼 말이죠.
토론에서 나온 이야기들은 밋업 시작 전 그날의 서기를 뽑아서 노션에 정리하도록 하였습니다. 개발밋업회를 통해 기술세미나가 열렸을 때는 구글밋 녹화기능을 이용해 사내에 세미나 녹화 파일을 공유하였습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;밋업을-진행하고-얻은-것&quot;&gt;밋업을 진행하고 얻은 것&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/socar-dev-meetup/socar-meetup.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 가장 주요한 발견으로, 조직별로 “지식의 사일로화”가 발생하고 있다는 것을 깨달았습니다. 조직이 전문 분야별로 나눠져 발달할 수는 있겠지만 상호 간에 기술 교류가 없으면 생각하지 못한 순간에 발목을 잡힙니다. 예를 들어 보자면 인프라 구조를 이해 못 해 과도한 컴퓨팅 비용을 지불한다던가, 잘못된 방식으로 배포한다던가 하는 일로 인해 시간비용을 소모하게 됩니다.&lt;br /&gt;
당연히 이러한 일들을 개발자는 회피하고 싶기에 사내 참고할만한 기술문서를 찾게 됩니다. 하지만 지속적으로 성장하며 변화가 빈번한 조직은 문서화 프로세스 하나 잡기도 만만치가 않습니다. 따라서 조직별로 기술문서는 만들고 있어도 다른 조직에서 참고하려면 무엇이 어디에 있는지도 몰라서 헤매는 일이 발생하게 되겠죠.&lt;br /&gt;
이러한 부분을 기술밋업회가 풀어주는데에는 성과가 있었습니다. 참석한 사람들이 궁금한 것들을 서로 물어보면서 채우기도 하고, 아예 하루 시간을 잡아 작은 세미나를 열기도 했지요. 심지어는 회사에서 권장하는 기술 블로그 쓰기에 대한 내용도 함께 이야기해볼 기회를 갖기도 했습니다.&lt;/p&gt;

&lt;p&gt;또한 새로운 기술을 스터디하는 데도 도움이 된다는 것을 발견했습니다. 조직이 전문분야로 나뉘면 각자의 도메인이 발달하게 됩니다. 따라서 새로운 기술 도입을 두고 이야기할 때 각 도메인끼리의 관점을 나누는데에도 효과적입니다. 밋업회를 통해 GO 언어를 스터디 할 수 있는 기회를 갖게 되었는데, 결국엔 쏘카라는 서비스를 만들고 운영할 때 최소한 현재 기준 어떤 도메인에서든 이점이 없다는 점을 평가할 수 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/socar-dev-meetup/go-tshirt.jpg&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;덤으로 중국산 티셔츠는 잘못 세탁하면 큰일 난다는 것도 배웠지요.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;그리고 고민은 나누는 것만으로도 가치가 있다는 것도 배웠습니다. 개발자 또는 한 조직의 구성원으로 털어놓기 어려운 주제도 던져봤는데 의외로 열띤 토론이 이어지는 경우가 많았습니다. 물론 밋업회 자체가 회사에서 업무 기능을 담당하지 않기에 토론 결과가 업무에 바로 반영되지는 않긴 합니다만, 서로 다른 조직끼리 “저 조직은 왜 우리와 다를까”라는 의문을 풀어주는 것만으로도 긍정적인 효과를 기대할 수 있다고 봅니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;next-step&quot;&gt;Next Step!&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/socar-dev-meetup/meetup-history2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;뒤돌아보니 정말 많은 주제들을 이야기 했군요 :)&lt;/p&gt;

&lt;p&gt;제 1회 개발밋업회가 열린 날은 2021년 5월 7일입니다. 생각 같아서는 매주 열고 싶지만, 여러 가지 사정이 있어서 매주 열지는 못하고 있긴 합니다.&lt;/p&gt;

&lt;p&gt;따라서 가장 중요한 다음 단계는 매주 열릴 수 있게 하는 것을 가장 큰 목표로 하고 있습니다.&lt;br /&gt;
또한 참여하는 사람을 늘리고 싶은 욕심도 간절합니다. 경험상, 밋업회에서 세미나를 연다고 하면 온라인으로 진행해도 문전성시를 이룰 정도로 참석자가 많은데 그렇지 않은 날에는 오는 사람만 오는 날이 많습니다. 그만큼 업무가 바쁘다는 거겠죠. 그 바쁜 와중에 밋업회가 숨통을 터주고 한 주를 마무리하는 시간이 되기를 원하고 있습니다.&lt;br /&gt;
그리고 무엇보다, 서비스를 개발하는 사람은 “내가 이것을 왜 만들지”라는 자각이 분명해야 한다고 생각합니다. 그런 자각의 유무에 따라 발생하는 품질의 차이도 만만치 않습니다. 개발밋업회가 조직 간의 경계를 허물고 서로의 이해증진을 추구한다면, 비 개발 직군의 이야기도 경청할 필요가 있다고 생각합니다. 그러한 자리를 열어주는 개발밋업회로 키워나갈까 합니다.&lt;/p&gt;

&lt;p&gt;마지막으로 시간을 내어 개발밋업회에 참여해주신 많은 동료들, 특히 항상 참여해주신 맷, 인클루, 바다, 빅서, 리스본, 험프리, 주노, 라네, 토니, 레이, 그리고 좋은 세미나 만들어 제공해주신 카일, 제이든, 타일러, 모두에게 감사 인사를 드립니다!!!&lt;/p&gt;</content><author><name>spock</name></author><category term="dev" /><category term="culture" /><summary type="html">Photo by DaeHyun Kim</summary></entry><entry><title type="html">Java Map의 확장 인터페이스 NavigableMap 이야기</title><link href="https://tech.socarcorp.kr/dev/2021/10/19/sub-interfaces-navigablemap.html" rel="alternate" type="text/html" title="Java Map의 확장 인터페이스 NavigableMap 이야기" /><published>2021-10-19T00:00:00+00:00</published><updated>2021-10-19T00:00:00+00:00</updated><id>https://tech.socarcorp.kr/dev/2021/10/19/sub-interfaces-navigablemap</id><content type="html" xml:base="https://tech.socarcorp.kr/dev/2021/10/19/sub-interfaces-navigablemap.html">&lt;p&gt;안녕하세요. 모빌리티 플랫폼 그룹 모비딕팀의 레이입니다.&lt;/p&gt;

&lt;p&gt;문제 하나로 글을 시작합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;어떤 항목 중에서 임의의 선택을 하되 가중치를 두어야 한다면 어떻게 구현할 수 있을까요?&lt;/li&gt;
  &lt;li&gt;예를 들어 빨강, 파랑, 초록 중 하나를 임의대로 추출하되 각각 5,3,2 만큼 가중치를 두고 싶습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;뜬금없이 가중치 문제로 시작했는데, 이 글에서 제시하는 답은 아래에 있습니다.
일단 각자 아는 방법대로 구현해 보고 제 방법과 비교해 보시기 바랍니다.&lt;/p&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Map 인터페이스와 세 가지 기본 구현체: HashMap, LinkedHashMap, TreeMap&lt;/li&gt;
  &lt;li&gt;Map 기능을 확장한 몇 가지 서브 인터페이스&lt;/li&gt;
  &lt;li&gt;오늘의 주제: NavigableMap&lt;/li&gt;
  &lt;li&gt;NavigableMap 인터페이스 구현체&lt;/li&gt;
  &lt;li&gt;간단한 사용 예제
    &lt;ul&gt;
      &lt;li&gt;1) 숫자 범위에 따른 값 할당&lt;/li&gt;
      &lt;li&gt;2) 가중치 문제 풀이&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;NavigableMap 전제 조건:&lt;/li&gt;
  &lt;li&gt;정리하며&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;map-인터페이스와-세-가지-기본-구현체-hashmap-linkedhashmap-treemap&quot;&gt;Map 인터페이스와 세 가지 기본 구현체: HashMap, LinkedHashMap, TreeMap&lt;/h2&gt;

&lt;p&gt;요즘에는 인터페이스와 구현체를 구분해서 변수를 선언하는 방법이 거의 자리를 잡은 듯 합니다.
다른 언어는 모르겠지만 자바로 제한한다면 예전에는 선언과 구현체 타입을 같게 지정하는 경우가 많았습니다.&lt;/p&gt;

&lt;p&gt;초기에 인터페이스 없이 달랑 구현체만 있던 &lt;code class=&quot;highlighter-rouge&quot;&gt;Hashtable&lt;/code&gt;이야&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 어쩔 수 없이&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Hashtable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Hashtable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;처럼 했을 수 있지만 컬렉션 프레임워크가 생긴 1.2 시절에도 이런 스타일은 흔히 볼 수 있었습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;HashMap&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러다가 업계의 개발 지식이 전반적으로 높아진 덕분인지 설계와 구현을 분리한 선언을 하는 방법이 거의 필수처럼 자리잡기 시작한 듯 합니다.
이제는 앞선 맵 할당을 다음과 같이 하는 경우가 대부분입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;우리 관심사는 map으로서 기능, 그러니까 &lt;strong&gt;어떤 키로 대응하는(map) 값을 찾는 기능이지 맵의 구현체가 실제로 어떠한지는 관심 대상이 아닙니다.&lt;/strong&gt;&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;
그런데 때로는 map의 키들이 어떤 순서를 유지하는지도 중요한 경우가 있습니다.
이런 때 사용할 수 있도록 준비해 놓은 구현체가 &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt; 입니다.
이런 경우에도 인터페이스를 사용한 선언에 구현체를 바꿔주기만 하면 이를 사용하는 다른 곳에서는 특별히 구현을 바꾸지 않더라도 다른 Map 구현체의 특징을 활용할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;은 저장하는 키에 특별한 순서를 보장하지 않습니다.
    &lt;ul&gt;
      &lt;li&gt;사실 대부분 map을 사용하는 목적 상 키 순서가 중요한 경우는 별로 없습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;키가 어떤 규칙에 따라 정렬이 되기를 원한다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt;을 사용하면 됩니다.&lt;/li&gt;
  &lt;li&gt;map에 저장하는 순서에 따라 정렬이 되기를 원하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;을 사용하면 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;보통은 이렇게 키의 정렬 순서를 특정하는 목적으로 세 가지 구현체를 상황에 맞게 사용하는 경우가 대부분입니다.
그리고 많은 사람들이 관심있는 동시성 처리와 관련한 &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt; 같은 특수한 환경 아래 동작하는 구현체 이야기는 쉽게 찾아 볼 수 있는데, 이 글에서는 조금 다른 이야기를 해 보려고 합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;map-기능을-확장한-몇-가지-서브-인터페이스&quot;&gt;Map 기능을 확장한 몇 가지 서브 인터페이스&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/Map.html&quot;&gt;Java API Doc&lt;/a&gt;(v9)을 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;의 서브 인터페이스는 11개 씩이나 됩니다.
이 중에서 “Map” 하고 관계 있어 보이는 대상은 다음처럼 7개입니다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentMap&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentNavigableMap&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ObservableMap&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ObservableMapValue&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SortedMap&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WritableMapValue&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;7가지 뿐만 아니라 11가지 인터페이스 모두를 다루었으면 좋겠지만 이 글에서는 이 중에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;이 무엇인지, &lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;의 구현체는 무엇인지를 이야기합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;오늘의-주제-navigablemap&quot;&gt;오늘의 주제: NavigableMap&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;을 설명하는 내용부터 약간 살펴 보겠습니다.
(&lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/NavigableMap.html&quot;&gt;https://docs.oracle.com/javase/9/docs/api/java/util/NavigableMap.html&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;문서를 보면, 첫 줄에&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;SortedMap&lt;/code&gt; extended with navigation methods returning the closest matches for given search targets.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이라고 했습니다.
이 문장이 &lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;의 특징을 설명하는 전부입니다.
이어서 다음 문장을 읽어 보겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Methods &lt;code class=&quot;highlighter-rouge&quot;&gt;lowerEntry(K)&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;floorEntry(K)&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ceilingEntry(K)&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;higherEntry(K)&lt;/code&gt; return &lt;code class=&quot;highlighter-rouge&quot;&gt;Map.Entry&lt;/code&gt; objects associated with keys respectively less than, less than or equal, greater than or equal, and greater than a given key, returning null if there is no such key.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 문장에서 어떻게 사용을 하는지 잘 설명하고 있습니다.
그런데 이 내용만 가지고 당장 어디에 써야겠다고 생각이 떠오르기는 쉽지 않습니다.
사실 저도 그러했습니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;이 무엇인지는 오래 전에 공부했지만 특별히 쓸 만한 곳은 없었습니다.
그러다가 최근 어떤 문제를 해결하려고 고민하던 중 문득 이 자료구조가 떠올랐고, 테스트 코드를 몇 줄 구현해 보면서 다행히 생각대로 잘 풀렸습니다.
공부한지 한참 지난 후 이제서야 쏘카에서 처음으로 실제 필요한 곳에 사용할 기회가 생긴 셈이지요.&lt;/p&gt;

&lt;p&gt;조금 더 API 문서를 훑어 보겠습니다.&lt;/p&gt;

&lt;p&gt;이 “인터페이스”는 &lt;code class=&quot;highlighter-rouge&quot;&gt;SortedMap&lt;/code&gt;&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; 인터페이스를 상속합니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NavigableMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SortedMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;“인터페이스”를 강조했습니다.
구현체가 아닌 인터페이스입니다.
인터페이스니까 어떤 동작을 제공하는지 계속해서 API문서를 살펴 보겠습니다.
앞서 보았던 두 번째 문장이 동작을 이해하려면 필요한 핵심 내용입니다.&lt;/p&gt;

&lt;p&gt;jdk 버전 9 기준 &lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt; 고유 메서드는 21개 이지만 이 중에서도 개인적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;의 특징을 잘 드러낸다고 생각하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;floorEntry()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ceilingEntry()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;lowerEntry()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;higherEntry()&lt;/code&gt; 네 가지를 설명하겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;navigablemap-인터페이스-구현체&quot;&gt;NavigableMap 인터페이스 구현체&lt;/h2&gt;

&lt;p&gt;앞에도 강조했지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;은 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4_(%EC%9E%90%EB%B0%94)&quot;&gt;인터페이스&lt;/a&gt;입니다.
그렇다면 구현체는 무엇일까요?&lt;/p&gt;

&lt;p&gt;그냥 &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt;을 사용하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TreeMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// (1)&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;NavigableMap&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TreeMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (2)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;약간 혼란을 느끼는 분이 있을 수도 있는데, 그래서 앞에 “인터페이스”를 강조했습니다.
같은 &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt; 구현체를 어떤 인터페이스로 사용하느냐에 따라 관점이 달라집니다.
어쩌면 이 이야기가 더욱 중요합니다.
우리의 관심사가 단순히 (키를 정렬한) &lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;인지, 제시한 요소와 방향에 가장 가까운 키를 찾으려는지에 따라 같은 &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt; 구현체라 해도 사용하는 API가 다릅니다.&lt;/p&gt;

&lt;p&gt;(1) 처럼 선언하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt; 구현체를 &lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt; 인터페이스로 들여다본다는 뜻이라서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;이 제공하는 25개의 메서드만 사용할 수 있으나,
(2) 처럼 선언하면 실제 메모리에 올라가는 구현체는 (1)과 같은 &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt;이지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;이 추가로 제공하는 고유한 메서드 21개를 더 사용할 수 있습니다&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;당연하게도 이러한 선언은 불가능합니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;NavigableMap&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;NavigableMap&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LinkedHashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt; 인터페이스를 상속하지 않은 구현체입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;의 메서드는 25개나 되지만 사실상 &lt;code class=&quot;highlighter-rouge&quot;&gt;get(key)&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;put(key, value)&lt;/code&gt; 말고는 사용하는 일이 거의 없습니다.
비슷하게 &lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;의 21개 메서드 중 4가지 메서드의 특징만 살펴보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;을 충분히 사용할 수 있으리라고 생각합니다&lt;sup id=&quot;fnref:5&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h2 id=&quot;간단한-사용-예제&quot;&gt;간단한 사용 예제&lt;/h2&gt;

&lt;h3 id=&quot;1-숫자-범위에-따른-값-할당&quot;&gt;1) 숫자 범위에 따른 값 할당&lt;/h3&gt;

&lt;p&gt;매우 간단한 예제를 살펴 보겠습니다&lt;sup id=&quot;fnref:6&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;(1부터 100까지) 숫자 범위에 따라 다른 방을 배정하려고 합니다.
if - else 구문을 사용하면 이 정도 되겠지요?&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;75&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// num &amp;lt;= 100&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;봄&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;50&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;75&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;여름&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;25&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;가을&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// num &amp;gt; 0&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;겨울&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;나쁘지 않습니다.
아마도 여러분은 더 좋은 구현 방법을 알고 있으리라 생각합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;으로 표현하면 어떨까요?
지금까지 했던 이야기를 바탕으로 이미 구현 방법을 떠올린 분도 계실 수 있다고 생각합니다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NavigableMap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TreeMap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;봄&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;75&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;여름&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;가을&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;겨울&quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ceilingEntry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;대략 이 정도 코드인데 전반적인 느낌을 이해하기는 어렵지 않으리라 생각합니다&lt;sup id=&quot;fnref:7&quot;&gt;&lt;a href=&quot;#fn:7&quot; class=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;.
ceiling 뜻 그대로, 전달한 인자보다 큰 쪽으로 가장 인접한 키값을 찾습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Returns the least key greater than or equal to the given key, or null if there is no such key.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;만약 &lt;code class=&quot;highlighter-rouge&quot;&gt;num = 69&lt;/code&gt; 였다면 69에 해당하는 키는 없지만 69보다 크면서 가장 가까운(작은) 키인 75를 선택합니다.
즉, (75, “여름”)이 해당하는 엔트리입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;floorEntry()&lt;/code&gt;는 반대로 전달한 인자보다 작은 쪽으로 가장 인접한 값을 찾겠지요?
물론 위/아래로 범위를 넘어서는 값을 주면 찾을 수 있는 값이 없습니다.
API 문서를 보면 이 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;을 반환한다고 명시했습니다.
위의 예제에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;m.ceilingEntry(101)&lt;/code&gt;이나 &lt;code class=&quot;highlighter-rouge&quot;&gt;m.floorEntry(0)&lt;/code&gt;이 &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;입니다.
이런 경우 상/하한 경계를 찾을 수 있는 장치로 &lt;code class=&quot;highlighter-rouge&quot;&gt;higherEntry()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;lowerEntry()&lt;/code&gt;가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;이 가능하려면 어떤 전제 조건이 필요합니다.
바로 “키를 어떤 순서대로 정렬해 놓아야 한다”겠지요.
&lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;의 상위 인터페이스가 &lt;code class=&quot;highlighter-rouge&quot;&gt;SortedMap&lt;/code&gt;이기도 하지만 구현체인 &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt;이 이러한 전제 조건을 만족하는 구현체입니다.
다른 &lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt; 구현체를 만들기 보다는 &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt;에 floor/ceil 등의 구현을 추가하는 편이 훨씬 합리적이었으리라 추측합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt;을 그저 키를 정렬한 맵 정도로 쓰다가 이제는 그 안에 숨어 있던 &lt;code class=&quot;highlighter-rouge&quot;&gt;SortedMap&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;이라는 다른 모습을 이해했습니다.
그렇다면 처음부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt;으로 선언하면 “키가 정렬된 &lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;“이라는 특징을 취하면서 동시에 &lt;code class=&quot;highlighter-rouge&quot;&gt;SortedMap&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;이 제공하는 모든 기능을 다 쓸 수 있는데 왜 &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt;을 타입으로 쓰지 않을까요?
이 내용은 글의 주제를 벗어나므로 깊이 다루지는 않겠지만 글 후반부에 설명하겠습니다.&lt;/p&gt;

&lt;p&gt;조금 더 쓸모있는 예제를 살펴볼까요?&lt;/p&gt;

&lt;h3 id=&quot;2-가중치-문제-풀이&quot;&gt;2) 가중치 문제 풀이&lt;/h3&gt;

&lt;p&gt;글 처음에 보여드린 문제 풀이입니다.
여러분은 어떤 방법으로 풀어 보셨나요? 해결 방법은 다양하지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;을 활용하면 비교적 간단하게 풀 수 있습니다.
비율이 2:3:5 이므로 키를 각각 2, 5(2+3), 10(2+3+5)으로 정합니다.
약간은 계산이 필요하네요.&lt;/p&gt;

&lt;p&gt;조금 더 이해하기 쉽도록 코드 위에 주석을 활용해 간단한 그림으로 표현했습니다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// | &amp;lt;-------5-------- | &amp;lt;---3---- | &amp;lt;-2-- |&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// |         R         |     G     |   B   |&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 10  9   8   7   6   5   4   3   2   1  (0)&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NavigableMap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TreeMap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;빨강&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;파랑&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;초록&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Random&lt;/code&gt;을 써서 이 맵을 탐색합니다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ceilEntry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;nextInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 문제 같은 경우에는 간격이 중요합니다.
간격만큼 랜덤으로 선택한 값이 걸릴 확률, 즉 가중치를 결정합니다.
선택한 값에 따라 경계값으로 설정한 키를 찾아가는 구조입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1, 2 가 나온다면: “파랑”,&lt;/li&gt;
  &lt;li&gt;3, 4, 5 라면: “초록”,&lt;/li&gt;
  &lt;li&gt;6, 7, 8, 9, 10 은: “빨강”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;을 반환하겠지요?
문제에서 요구한 5:3:2 가중치로 항목을 선택합니다.&lt;/p&gt;

&lt;p&gt;매우 직관적이면서도 간결한 구현입니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;navigablemap-전제-조건-sortedmap&quot;&gt;NavigableMap 전제 조건: SortedMap&lt;/h2&gt;

&lt;p&gt;만약 &lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;을 구현한다고 가정한다면 키 항목 구성은 어떤 전제 조건이 필요할까요?
&lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;에서 제시하는 키를 찾는 방법을 다시 살펴보면, 어떤 값을 주고 이 값 보다 크거나 작은 방향으로 가장 가까이 위치한 키를 찾습니다.
즉, 키 요소를 어떤 기준에 따라 정렬해 놓지 않으면 안 됩니다.
그래서 &lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;의 상위 인터페이스로서 &lt;code class=&quot;highlighter-rouge&quot;&gt;SortedMap&lt;/code&gt;은 매우 자연스런 모습입니다.
Java에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;SortedMap&lt;/code&gt;이나 &lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt; 구현체가 따로 존재하지 않고 &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt; 하나로 이 두 가지 인터페이스를 모두 만족하도록 구현해 놓았습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;SortedMap&lt;/code&gt;을 확장(상속)한 인터페이스라서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;SortedMap&lt;/code&gt;에서 제공하는 api(메서드)를 모두 사용할 수 있겠지요.
&lt;code class=&quot;highlighter-rouge&quot;&gt;SortedMap&lt;/code&gt;으로 선언하든 &lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;으로 선언하든 어차피 &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt;을 할당해야 할 테니 구현체 차이는 없겠지만 그래도 사용 목적에 따라 적절한 인터페이스를 사용해야 합니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;SortedMap&lt;/code&gt;이 필요한 구현인데 굳이 &lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;으로 선언해서 훗날 코드를 읽는 누군가에게 혼란을 초래할 필요는 없겠지요.
같은 &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt;을 할당하더라도 정말로 필요한 목적에 따라 인터페이스를 적절히 구분해 사용했을 때 해당 코드를 들어다보는 동료들이 조금이나마 모호한 상황을 훨씬 적게 겪을 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;그저 정렬된 키셋이 필요한 경우라면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;인터페이스로 충분합니다.&lt;/li&gt;
  &lt;li&gt;정렬된 키를 기준으로 이런저런 부분 맵이 필요하다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;SortedMap&lt;/code&gt; 인터페이스를,&lt;/li&gt;
  &lt;li&gt;키 탐색이 필요하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;을 사용합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그냥 &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt;으로 선언했다면 코드를 자세히 들여다보지 않는 이상 어떤 목적으로 사용하려 했는지 알기가 어렵겠지요.
그나마 주석을 달아 놓았다면 조금은 덜 혼란스러울 수도 있겠지만 코드 자체에 의도와 목적을 분명하게 드러낼 수 있다면 그렇게 하는 편이 더 좋습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SortedMap&lt;/code&gt;도 흥미로운 주제이니 각자 살펴 보시기 바랍니다.
저는 아직 &lt;code class=&quot;highlighter-rouge&quot;&gt;SortedMap&lt;/code&gt;을 써야 할 만한 문제를 겪지는 않았습니다.
언젠가는 이를 써서 해결해야 할 문제를 마주하게 될 날도 오겠지요.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;정리하며&quot;&gt;정리하며&lt;/h2&gt;

&lt;p&gt;Map은 상당히 많이 사용하는 자료 구조입니다.
대부분 &lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt; 정도면 충분하지만 때로는 키 정렬 순서 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt;을 사용하는 경우가 종종 있습니다.
비슷한 &lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt; 계열에서도 동시성 문제 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;을 사용하는 경우도 있고 메모리 문제 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;WeakHashMap&lt;/code&gt;을 사용하는 경우도 있지만 상황에 따라 구현체를 바꾸었을 뿐 &lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt; 인터페이스 범주를 벗어나지 않는 선에서 사용하는 경우가 대부분입니다.&lt;/p&gt;

&lt;p&gt;내부 구현의 차이가 있지만 단순한 키 - 값 대응만 사용하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt; 을 넘어서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;의 확장 인터페이스인  &lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt; 관점으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt; 구현체를 어떻게 사용할 수 있는지 간략히 살펴 보았습니다.&lt;/p&gt;

&lt;p&gt;다음에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;으로 조금 더 깊이 있는 활용 사례를 선보이는 시간을 갖도록 하겠습니다.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;엄밀히 이야기하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Hashtable&lt;/code&gt;은 추상 클래스인 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt;를 상속한 구현체입니다. 자바 설계 당시 인터페이스 개념은 추상 클래스보다 늦게 도입한 개념입니다. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;제네릭은 이 글에서 다루는 주제가 아니기도 하고 다룰 필요도 없어서 과감히 생략합니다. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;이 &lt;code class=&quot;highlighter-rouge&quot;&gt;SortedMap&lt;/code&gt;을 상속하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;SortedMap&lt;/code&gt;이 &lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;을 상속하니 &lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt; 이전에 &lt;code class=&quot;highlighter-rouge&quot;&gt;SortedMap&lt;/code&gt; 특징을 설명하면 더욱 좋겠지만 주제를 벗어난다고 판단하여 생략합니다.  다만 &lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;을 설명하다 보면 매우 간략하기는 해도 자연스럽게 &lt;code class=&quot;highlighter-rouge&quot;&gt;SortedMap&lt;/code&gt; 특성도 언급하기는 합니다. &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SortedMap&lt;/code&gt; 까지 생각하면 조금 차이는 있으나 넘어가겠습니다 &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:5&quot;&gt;
      &lt;p&gt;제가 만든 애플리케이션에서도 4개의 메서드만 사용합니다. &lt;a href=&quot;#fnref:5&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:6&quot;&gt;
      &lt;p&gt;여기부터 편의 상 코틀린 코드를 사용합니다. &lt;a href=&quot;#fnref:6&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:7&quot;&gt;
      &lt;p&gt;num 입력값을 1~100으로 제한하지 않으면 이 구현에는 문제가 있지만, 조건을 제한하여 실행했다고 가정한다면 문제는 없습니다. &lt;a href=&quot;#fnref:7&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>ray</name></author><category term="dev" /><category term="server" /><category term="java" /><summary type="html">안녕하세요. 모빌리티 플랫폼 그룹 모비딕팀의 레이입니다.</summary></entry><entry><title type="html">쏘카 안드로이드 팀 신입 개발자 미뇽의 입사기</title><link href="https://tech.socarcorp.kr/dev/2021/08/19/join-in-socar-android.html" rel="alternate" type="text/html" title="쏘카 안드로이드 팀 신입 개발자 미뇽의 입사기" /><published>2021-08-19T00:00:00+00:00</published><updated>2021-08-19T00:00:00+00:00</updated><id>https://tech.socarcorp.kr/dev/2021/08/19/join-in-socar-android</id><content type="html" xml:base="https://tech.socarcorp.kr/dev/2021/08/19/join-in-socar-android.html">&lt;p&gt;안녕하세요. 소프트웨어 학과를 졸업하고 올해 3월에 입사하여 쏘카 안드로이드 팀에서 일하고 있는 신입 개발자 미뇽(최민정)입니다.&lt;/p&gt;

&lt;p&gt;저는 개발한 기능을 직접 사용하고 싶었기 때문에 흔히 말하는 대기업, 공기업보다 자체 서비스를 가진 IT 회사를 가고 싶었습니다. 하지만 제가 가고자 하는 IT 회사들의 정보는 턱없이 부족했고, 대학 내에서 제가 원하는 방향으로 취업을 한 사례를 찾는 것도 힘들었습니다.&lt;/p&gt;

&lt;p&gt;이 글에서는 제가 취업을 준비할 당시 &lt;strong&gt;어떤 기준으로 지원할 회사를 생각했는지&lt;/strong&gt;, 그리고 &lt;strong&gt;쏘카 안드로이드 팀에 합류한 이후 신입 개발자로서 어떤 것들을 느꼈는지&lt;/strong&gt; 소개합니다. 이 글이 IT 서비스 회사로 취업을 준비하시는 분들에게 도움이 되었으면 좋겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;입사 전
    &lt;ul&gt;
      &lt;li&gt;취준생 시절 회사 선정 기준&lt;/li&gt;
      &lt;li&gt;쏘카를 선택한 이유&lt;/li&gt;
      &lt;li&gt;아쉬웠던 점&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;입사 후
    &lt;ul&gt;
      &lt;li&gt;안드로이드 팀의 장점&lt;/li&gt;
      &lt;li&gt;아쉬웠던 점&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;마무리&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;입사-전&quot;&gt;입사 전&lt;/h2&gt;

&lt;h3 id=&quot;취준생-시절-회사-선정-기준&quot;&gt;취준생 시절 회사 선정 기준&lt;/h3&gt;

&lt;p&gt;자신에게 맞는 회사를 택하는 것이 저와 회사의 기회비용을 줄일 수 있다고 생각했습니다. 저와 맞는 회사를 택하기 위해서는 제가 원하는 회사의 기준이 명확해야 하기 때문에, 이력서를 넣기 전에 어떤 회사에 들어가고 싶은지 기준을 정해보았습니다.&lt;/p&gt;

&lt;h4 id=&quot;1-팀-인원이-5명-이상인-회사&quot;&gt;1) 팀 인원이 5명 이상인 회사&lt;/h4&gt;

&lt;p&gt;신입 개발자인 저에게 가장 중요한 요소 중 하나는 &lt;strong&gt;성장할 수 있는 회사 여부&lt;/strong&gt;입니다. 서비스 하나를 혼자서 개발하는 경험도 성장에 좋은 영향을 끼칠 수 있지만, 경험을 바탕으로 방향성을 제시해 줄 수 있는 선배가 있는 것은 성장에 더 큰 영향을 끼칠 수 있습니다.&lt;/p&gt;

&lt;p&gt;또한 당장 업무에 투입되는 것보다는 업무에 대한 이해가 어느 정도 끝난 상태에서 업무를 진행하는 것이 회사와 개발자 모두에게 좋다고 생각합니다. 이렇게 방향성을 제시해 줄 선배가 있고, 업무를 이해할 시간을 확보할 환경이 마련되기 위해서는 팀 인원이 어느 정도 많아야 한다고 생각합니다. 저는 그 기준을 5명으로 잡았습니다.&lt;/p&gt;

&lt;h4 id=&quot;2-내가-사용하고-싶은-서비스를-가진-회사&quot;&gt;2) 내가 사용하고 싶은 서비스를 가진 회사&lt;/h4&gt;

&lt;p&gt;회사에서 운영하는 서비스가 &lt;strong&gt;‘내가 사용하고 싶은 서비스인가?’&lt;/strong&gt;에 대해 고민해봐야 한다고 생각합니다. 회사에서 운영하는 서비스는 결국 제가 개발해야 하는 서비스입니다. 제가 사용하고 싶은 서비스를 직접 개발하고 배포하면 만족도가 더 크다고 생각합니다. 또한 직접 서비스를 사용하기도 하므로, 서비스의 개선할 점과 방향성에 대한 파악이 손쉽다고 생각합니다.&lt;/p&gt;

&lt;h4 id=&quot;3-단순한-기능feature-개발-외에-코드의-장기적인-생산성을-생각해주는-회사&quot;&gt;3) 단순한 기능(Feature) 개발 외에 코드의 장기적인 생산성을 생각해주는 회사&lt;/h4&gt;

&lt;p&gt;개발자가 회사에 얻고자 하는 것은 월급뿐만 아니라 &lt;strong&gt;좋은 코드에 대한 경험&lt;/strong&gt;도 있다고 생각합니다. 하지만 회사가 좋은 코드를 위해 리소스를 투자하는 것은 당연하지 않습니다. 회사의 목적은 이익이고, 좋은 코드와 아키텍처에 대한 투자는 리소스 낭비가 될 수 있기 때문입니다. 당연하지 않은 일이기에 코드와 아키텍처에 투자하는 회사는 이에 대해 관심이 많은 회사이고, 개발자로서 좋은 코드에 대한 경험을 얻을 수 있다고 생각했습니다.&lt;/p&gt;

&lt;h3 id=&quot;쏘카를-선택한-이유&quot;&gt;쏘카를 선택한 이유&lt;/h3&gt;

&lt;p&gt;쏘카는 3가지 기준에 부합하는 회사입니다. 임직원이 300명 이상이고 카쉐어링이라는 매력적인 분야에 큰 입지를 가진 회사인 동시에 현재 안드로이드 팀의 인원이 5명 이상입니다. 회사의 코드와 아키텍처에 대한 정보를 온라인상에서 얻기는 어려웠으나 면접 과정에서 쏘카의 코드에 대해 자신 있게 설명하는 모습에서 좋은 코드에 투자하는 회사임을 알았습니다.&lt;/p&gt;

&lt;p&gt;3가지 기준 외에도 쏘카는 데이터라는 매력 포인트를 가지고 있습니다. 쏘카는 많은 사용자를 보유한 서비스로 다양한 데이터를 가지고 있으며, 이를 활용하고자 독립적인 데이터 조직을 운영하고 있습니다. 데이터 팀에서 데이터를 분석하여 제공한 객관적인 수치를 통해 다각도로 사용자의 니즈를 파악하고 있습니다. 이러한 객관적인 자료로 제가 개발하는 기능이 어떤 영향을 끼치는지 확인할 수 있습니다. 다양한 데이터와 이를 분석하여 이용할 수 있는 능력을 갖추고 있는 것이 쏘카의 또 다른 매력 포인트입니다.&lt;/p&gt;

&lt;h3 id=&quot;아쉬웠던-점&quot;&gt;아쉬웠던 점&lt;/h3&gt;

&lt;p&gt;쏘카에 입사 지원할 때 아쉬웠던 점은 팀의 기술적인 내용이나 개발 문화를 외부에서 알기 어려웠다는 점입니다. 회사에서 기술 블로그를 운영하고 있으나 실질적으로 사용하는 기술 혹은 개발문화에 관해 서술된 게시글은 없었습니다. 입사 이후 알아보니 쏘카에서 발표한 일부의 자료를 공개한 &lt;a href=&quot;https://speakerdeck.com/socar&quot;&gt;사이트&lt;/a&gt;도 있었고, 회사에서 블로그 작성을 장려하기 위해 다양한 혜택을 마련하고 있습니다. 이러한 회사의 노력은 블로그의 활성화를 가져오고 있습니다. 앞으로 &lt;a href=&quot;https://tech.socarcorp.kr&quot;&gt;블로그&lt;/a&gt;를 통해 쏘카의 기술적인 이야기를 전달해 드릴 수 있을 것 같습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;입사-후&quot;&gt;입사 후&lt;/h2&gt;

&lt;p&gt;쏘카의 문화는 수평 그 자체였습니다. 회사 내에서 닉네임을 사용하고, 닉네임 뒤에 직책, 님 등을 붙이지 않습니다. 닉네임만 수평적인 것이 아니었습니다. 회사의 모든 이들이 서로를 상호 존중하고, 회사 업무와 관련된 내용은 다 공개되며 모든 이들이 내용을 확인할 수 있게 되어있었습니다. 또한 누구든 회사에 도움이 될만한 의견과 질문하는 것을 환영합니다.&lt;/p&gt;

&lt;h3 id=&quot;안드로이드-팀의-장점&quot;&gt;안드로이드 팀의 장점&lt;/h3&gt;

&lt;h4 id=&quot;1-하나의-질문에-함께-고민하는-문화&quot;&gt;1) 하나의 질문에 함께 고민하는 문화&lt;/h4&gt;

&lt;p&gt;신입 개발자로 첫 회사에 입사한 만큼 사소한 것 하나조차도 질문할 수밖에 없었습니다. 팀원 그 누구도 질문을 귀찮아하지 않았습니다. 심지어 사소한 문제라 할지라도 질문을 받은 팀원 이외의 다른 팀원도 함께 관심을 두고 해당 내용을 함께 고민해주었습니다. 처음에는 익숙하지 않아 부담스럽기도 했지만 이게 안드로이드 팀의 문화라는 한 팀원의 말에 이제는 부담보다는 함께 고민해보고자 노력하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/join-in-socar-android/talk-in-slack.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기존의 토의는 오프라인상에서 많이 이뤄졌지만, 재택근무가 많은 현시점에서는 슬랙, 디스코드를 통해 질문을 주고받습니다. 더 좋은 아이디어가 있다면 주저하지 않고 자신의 의견을 얘기하는 것이 안드로이드 팀의 문화입니다.&lt;/p&gt;

&lt;h4 id=&quot;2-적극적인-코드-리뷰&quot;&gt;2) 적극적인 코드 리뷰&lt;/h4&gt;

&lt;p&gt;팀마다 규칙이 다르지만, 안드로이드 팀은 전체 팀원 중 3명 이상에게 Approve를 받아야 Merge를 할 수 있습니다. 아무리 바쁘다고 하더라도 리뷰를 대충하지 않습니다. 안드로이드 팀은 “빠르게 Merge를 해야 하는 Pull Request라면 리뷰를 대충하는 것이 아니라 리뷰에 더 많은 시간을 투자해야 한다”라는 마인드를 가지고 있습니다. 이 문화 속에서 저는 더 도움 되는 리뷰를 남겨보고자 노력 중입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/join-in-socar-android/pull-request.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 사진은 입사 이후 제가 지금까지 작성한 Pull Request입니다. 네이밍부터 로직 상에 더 좋은 아이디어를 제안하는 것까지 다양한 코멘트를 작성 받아서 한 PR에 최대 84개의 코멘트를 받은 적도 있습니다. 쏘카 안드로이드 팀이 코드 리뷰하는 방법이 더 궁금하다면 &lt;a href=&quot;https://speakerdeck.com/socar/kodeu-ribyu-jeogeunggi&quot;&gt;해당 링크&lt;/a&gt;를 확인해주세요.&lt;/p&gt;

&lt;h4 id=&quot;3-서로-발전하려는-문화&quot;&gt;3) 서로 발전하려는 문화&lt;/h4&gt;

&lt;p&gt;안드로이드 팀의 경우는 매주 금요일에 &lt;code class=&quot;highlighter-rouge&quot;&gt;개수다&lt;/code&gt;라는 것을 진행합니다. 기술적인 것 외에도 팀원들에게 도움이 될만한 내용을 서로 공유하는 시간입니다. 개수다에서 공유된 내용이 실제 쏘카 앱에 적용되어 좀 더 나은 코드를 생성하는 것으로 연결되는 경우도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/join-in-socar-android/gaesuda.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 사진은 실제 안드로이드 팀에서 진행한 개수다 내용이 적혀진 것을 캡쳐한 것입니다. 기술적인 내용 외에도 다양한 내용을 함께 이야기하고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;아쉬웠던-점-1&quot;&gt;아쉬웠던 점&lt;/h3&gt;

&lt;p&gt;안드로이드 팀은 만족스러웠으나 두 가지 아쉬운 점이 있었습니다. 첫째로 팀 내 문서화가 잘되지 않은 것입니다. 둘째로 외부에서 회사의 기술 및 개발 문화를 알 수 없었습니다. 팀 내 문서화의 경우 상대적으로 업무가 적은 제가 많은 내용을 문서화하기 위해 노력 중이며, 외부에 노출하는 것은 현재 기술 블로그를 활성화하는 방향으로 개선하려고 하고 있습니다.&lt;/p&gt;

&lt;p&gt;안드로이드 팀은 좋은 방향으로 성장하기 위해 항상 노력하고 있습니다. 물론 안드로이드 팀뿐만 아니라 쏘카의 모든 팀이 한 발짝 더 나아가기 위해 노력하고 있습니다. 항상 노력하고자 하는 모습도 좋지만, 쏘카에 와서 가장 만족한 것은 좋은 사람들입니다. 지금은 코로나 4단계로 전사 재택근무 중이라 어렵지만, 이전에 회사에 출근해서 얘기하고, 함께 식사하는 시간이 너무나도 즐거웠습니다. 아래의 사진처럼 벚꽃이 이쁘게 핀 날 피크닉 가듯이 식사를 하기도 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/join-in-socar-android/lunch-with-company.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;마무리&quot;&gt;마무리&lt;/h2&gt;

&lt;p&gt;이 글은 저의 경험을 서술하는 글이며 이 글을 보시는 많은 분들이 쏘카에 관심 갖고, 쏘카에 입사하셔서 더 많은 분들과 좋은 시간을 보내기를 바라는 약간의 사심이 들어가 있는 글이기도 합니다. 더 많은 사람을 쏘카로 모시고자 안드로이드 팀원들이 저희 팀에 관심있는 분들에게 남기고 싶은 한마디를 작성해보았습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;미뇽 (ENTP): 매주 미뇽의 추천곡을 들으실 수 있습니다.
로니 (ISFP): 사내 어떤 팀보다 원격 근무에 진심인 사람들. 슬랙콜? ㄴㄴ 디스코드 ㅇㅇ
아릉 (INTJ): 키보드 만들고 밀링머신 돌리고.. 이상한 사람들 많이 들어왔으면 좋겠습니다.
지안 (INTP): 미래적인 안드로이드 코딩으로 모빌리티를 함께하실 분을 찾습니다. 그리고... 키보드 좋아하시나요?
알파카 (INFP): 맛집 좋아하시나요?
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;현재 쏘카 안드로이드 팀은 &lt;strong&gt;주니어, 시니어에 무관하게 채용 중&lt;/strong&gt;입니다. 안드로이드 팀 외에도 쏘카의 채용은 모두 열려있습니다. 카쉐어링 분야와 쏘카에 관심 있고, 수평적 문화 속에서 좋은 사람들과 즐겁게 일할 분을 기다리고 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>mignon</name></author><category term="dev" /><category term="android" /><summary type="html">안녕하세요. 소프트웨어 학과를 졸업하고 올해 3월에 입사하여 쏘카 안드로이드 팀에서 일하고 있는 신입 개발자 미뇽(최민정)입니다.</summary></entry><entry><title type="html">쏘카 백오피스 팀 내 공통 코드(Common Code) 관리 변천사</title><link href="https://tech.socarcorp.kr/dev/2021/08/17/common-code-management.html" rel="alternate" type="text/html" title="쏘카 백오피스 팀 내 공통 코드(Common Code) 관리 변천사" /><published>2021-08-17T06:10:00+00:00</published><updated>2021-08-17T06:10:00+00:00</updated><id>https://tech.socarcorp.kr/dev/2021/08/17/common-code-management</id><content type="html" xml:base="https://tech.socarcorp.kr/dev/2021/08/17/common-code-management.html">&lt;p&gt;저희 팀은 쏘카 R&amp;amp;D 본부에서 다양한 백오피스 개발을 담당하고 있습니다. 백오피스 개발에 사용되는 기술 스택은 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; Database: MySQL
&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; Server Framework: SpringBoot
&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; Frontend Framework: Vue.js
&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; Language: Kotlin / JavaScript(일부는 TypeScript)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;공통-코드common-code를-어떻게-관리하고-사용할-것인가&quot;&gt;공통 코드(Common Code)를 어떻게 관리하고 사용할 것인가?&lt;/h2&gt;

&lt;p&gt;개발을 하다 보면 상태를 표현하는 값이나 변경 빈도가 낮은 분류(Category) 등을 공통 코드로 관리하게 됩니다.
프론트엔드(Vue.js)에서 일반적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;raido&lt;/code&gt;를 표시할 때 데이터로 사용하고 서버(Kotlin)에서는 비즈니스 로직을 작성할 때 사용하게 되고 DB에도 저장되게 됩니다.&lt;/p&gt;

&lt;p&gt;실제 저희팀에서는 이런 것들을 공통코드로 정의해서 사용하고 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; 정산유형 - 자동 / 수동
&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; 정산상태 - 대기중 / 미납 / 완료 / 취소
&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; 정산항목 - 대여요금 / 정비요금 / 보증금 / 주유비 / 인수탁송 ....
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;공통코드는 변경 빈도가 높지는 않지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;DB - 서버 - 프론트엔드&lt;/code&gt;에 걸쳐 넓은 범위에서 다양하게 사용되므로 변경이 일어나면 프로젝트를 구성하는 거의 모든 계층이 영향을 받으므로 적절하게 관리하고 사용되어야 합니다.&lt;/p&gt;

&lt;p&gt;이 글에서 저희 팀이 신규 프로젝트를 설계하는 과정에서 공통코드를 관리하기 위해 어떤 시도를 해왔고, 어떻게 보완해 왔는지 정리해 보려고 합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;들어가기-전에&quot;&gt;들어가기 전에&lt;/h2&gt;
&lt;p&gt;공통 코드 관리를 어떻게 하면 되느냐? 에 대한 결론부터 말씀드리면 &lt;code class=&quot;highlighter-rouge&quot;&gt;정답은 없다&lt;/code&gt;고 생각합니다.&lt;/p&gt;

&lt;p&gt;비슷한 고민을 하시는 분들에게 저희 팀의 시행착오가 참고될 수 있을까 해서 저희 팀이 공통 코드 처리를 위해 어떤 고민을 하고 어떤 방법으로 불편한 점을 해소했는지를 작성했습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1차-공통-코드-구조-설계-및-초기-구현&quot;&gt;(1차) 공통 코드 구조 설계 및 초기 구현&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/common-code1.png&quot; alt=&quot;공통코드-1차&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;팀에서-결정한-내용&quot;&gt;팀에서 결정한 내용&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;코드를 어떻게 분류할 것인가?
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;부모 코드-자식 코드&lt;/code&gt;로 분류&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;코드를 어떻게 저장할 것인가?
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DB&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;부모 코드(code_group) / 자식 코드(code) 2개의 테이블&lt;/code&gt;을 만들어서 저장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;코드를 어떻게 사용할 것인가?
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DB&lt;/code&gt;에 저장할 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;문자열&lt;/code&gt;로 저장&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;에서 사용할 때는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ENUM&lt;/code&gt;을 정의해 두고 사용&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt;에서 사용할 때는 서버에서 API로 필요한 코드를 조회해서 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;각 사용처의 코드를 어떻게 Sync 할 것인가?
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DB&lt;/code&gt; - 기준 데이터&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;서버(Kotlin)&lt;/code&gt; - DB에 입력된 값을 기준으로 ENUM을 생성하는 유틸(&lt;code class=&quot;highlighter-rouge&quot;&gt;codeGenerator&lt;/code&gt;)을 만들어 사용&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;프론트엔드(JavaScript)&lt;/code&gt; - 서버에서 필요한 코드를 DB에서 조회할 수 있는 API를 만들고 필요시 요청해서 사용&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;개발자&lt;/code&gt; - DB에 입력하기 위한 Insert 문을 팀 공통 문서(Notion)에 관리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;코드의 이름 규칙은 어떻게 할 것인가?
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;부모 코드&lt;/code&gt;는 이름과 함께 &lt;code class=&quot;highlighter-rouge&quot;&gt;5자리의 PREFIX&lt;/code&gt;를 부여&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;자식 코드&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;PREFIX_XXX&lt;/code&gt; 형태의 이름을 사용&lt;/li&gt;
      &lt;li&gt;대문자 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;결정의-배경&quot;&gt;결정의 배경&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://velog.io/@leejh3224/%EB%B2%88%EC%97%AD-MySQL%EC%9D%98-ENUM-%ED%83%80%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%A7%90%EC%95%84%EC%95%BC-%ED%95%A0-8%EA%B0%80%EC%A7%80-%EC%9D%B4%EC%9C%A0&quot;&gt;MySQL의 ENUM 단점&lt;/a&gt;이 많으니 사용하지 말고 &lt;code class=&quot;highlighter-rouge&quot;&gt;문자열&lt;/code&gt;로 사용합니다.
    &lt;ul&gt;
      &lt;li&gt;ENUM의 순서 변경이 있을 경우 테이블이 잠기고, 시간이 데이터의 양에 따라 기하급수적으로 늘어날 수 있습니다.&lt;/li&gt;
      &lt;li&gt;숫자로 할 경우 DB에서 직접 조회 시 코드의 의미를 추측할 수 없습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;코딩 시 공통 코드를 문자열로 쓰진 않았으면 했습니다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt; 쪽은 DB에 있는 공통 코드를 읽어서 &lt;a href=&quot;https://square.github.io/kotlinpoet/&quot;&gt;kotlinpoet&lt;/a&gt;을 활용해서 ENUM 클래스들을 생성하기로 했습니다. (&lt;code class=&quot;highlighter-rouge&quot;&gt;codeGenerator&lt;/code&gt;)&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript&lt;/code&gt; 쪽은 서버에서 코드 조회를 위한 API를 만들어 두고 조회해서 사용합기로 했습니다. 하지만 실제 코드 값을 바로 사용할 때는 값을 바로 문자열로 사용하기로 했습니다.
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Javascript&lt;/code&gt;에서도 Kotlin의 ENUM처럼 상수로 선언해 두고 사용하고 싶었으나 신규 프로젝트를 진행하는 과정에서 이루어진 결정이라 Javascript에서 사용성은 일부 포기하였습니다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공통 코드 목록을 구글 시트에 정리해 두는 방법도 고민하였으나 개발 초기에 공통코드가 공유되어야 하는 대상이 개발자뿐이라 그냥 insert 문을 Notion에 붙여두고 관리하기로 했습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;실제-사용-예시&quot;&gt;실제 사용 예시&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;개발자 간 공유를 위한 Insert 쿼리
    &lt;ul&gt;
      &lt;li&gt;Notion 문서에 공통 코드를 작성하고, 공통 코드를 변경한 개발자가 직접 해당 SQL을 수정한 후, 팀 내에 코드가 변경된 사실을 공유하는 방식으로 관리합니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;코드&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;그룹&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;생성&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INTO&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`code_group`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`name`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`prefix`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`description`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;VALUES&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'SETTLEMENT_TYPE'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'STLTP_'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'비용 발생 유형'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;코드&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;생성&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INTO&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`code`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`group`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`name`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`label`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`description`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`order`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;VALUES&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'SETTLEMENT_TYPE'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'STLTP_AUTO'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'자동'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'SETTLEMENT_TYPE'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'STLTP_MANUAL'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'수동'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;생성된 Kotlin ENUM 코드 &lt;a name=&quot;generated_kotlin_code&quot;&gt;&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;공통 코드를 변경한 개발자가 generator를 돌려서 kotlin 코드를 생성 후 GIT에 Commit합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Codes&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ... other codes ...&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SettlementType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;AUTO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;자동&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;STLTP_AUTO&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;

        &lt;span class=&quot;nc&quot;&gt;MANUAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;수동&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;STLTP_MANUAL&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;companion&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getByValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SettlementType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;find&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ... other codes ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Vue.js에서 사용할 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 공통 코드 가져오기&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;codes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;CodeApi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getByGroups&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;SETTLEMENT_TYPE&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 공통 코드 값 비교&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;STLTP_AUTO&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 공통 코드 =&amp;gt; 라벨 변환&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;getCodeLabel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;codes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;codes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;codes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;사용-후-발견한-불편한-점&quot;&gt;사용 후 발견한 불편한 점&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;공통 코드를 변경할 때마다 신경써야 할 것들이 너무 많습니다.
    &lt;ul&gt;
      &lt;li&gt;추가할 코드를 Insert 문으로 작성해 DB에 입력 및 Notion 문서 갱신&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;codeGenerator&lt;/code&gt;를 돌려서 Kotlin 코드 생성&lt;/li&gt;
      &lt;li&gt;Kotlin 코드를 Git에 commit&lt;/li&gt;
      &lt;li&gt;코드 변경된 사항을 팀원에게 공유&lt;/li&gt;
      &lt;li&gt;다른 팀원들은 로컬 DB에 추가된 코드 추가 &amp;amp; Git pull&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1.&lt;/code&gt;의 절차가 너무 복잡해서 에러를 만나는 경우가 많습니다.
    &lt;ul&gt;
      &lt;li&gt;Kotlin ENUM 코드와 로컬 DB의 값이 서로 달라서 에러 발생.
        &lt;ul&gt;
          &lt;li&gt;A 개발자가 공통 코드 변경이 필요한 개발 건을 진행하고 그 코드가 머지된 이후 다른 B 개발자가 pull을 받은 후, 이어서 다른 개발을 진행하려고 할 때 로컬 DB에는 아직 신규 코드가 추가 되지 않아 매번 에러를 경험하게 됩니다. 이 때 B 개발자는 Notion에 있는 변경된 Insert 쿼리를 로컬 DB에 실행해야 하는데, 이 과정이 번거롭게 느껴졌습니다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript 공통코드 값 비교&lt;/code&gt; 할 때 문자열로 사용하는 것이 꺼림칙합니다.
    &lt;ul&gt;
      &lt;li&gt;코드 컨벤션을 깔끔하게 유지하고 싶어 하는 팀원들이 많기도 하고, 코딩할 때 해당 코드의 실제 값을 DB나 Kotlin 코드에서 찾아 복사해야 하는 것이 불편합니다.&lt;/li&gt;
      &lt;li&gt;또한 복사하지 않고 직접 타이핑시 오타로 인한 버그도 발생할 수 있었습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;JavaScript에서 필요할 때마다 코드를 API로 가져오는데, 너무 자주 필요합니다(코드 조회를 위한 API 요청이 너무 많습니다)
    &lt;ul&gt;
      &lt;li&gt;백오피스 서버 / 프론트엔드를 모두 팀에서 개발하는데 나눠서 해야 하나요?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2차-불편함-개선-작업db를-빼버리자&quot;&gt;(2차) 불편함 개선 작업(DB를 빼버리자!)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/common-code2.png&quot; alt=&quot;공통코드-2차&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;공통-코드를-변경할-때마다-db와-코드를-sync-시키는-작업을-없애봅시다&quot;&gt;공통 코드를 변경할 때마다 DB와 코드를 Sync 시키는 작업을 없애봅시다&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;DB에서 직접 데이터를 확인할 때 공통 코드 테이블을 join해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;공통 코드 -&amp;gt; 라벨&lt;/code&gt;로 변경해서 쿼리하는 경우가 생각보다 없었습니다.&lt;/li&gt;
  &lt;li&gt;위 케이스를 제외하면 DB를 사용하는 것은 프론트엔드를 위해 서버에서 API로 코드를 내려줄 때 DB를 조회해서 내리는 곳밖에 없었습니다.&lt;/li&gt;
  &lt;li&gt;그렇다면! DB에서 코드 테이블을 삭제해버리고 &lt;code class=&quot;highlighter-rouge&quot;&gt;codeGenerator로 DB에서 생성한 Kotlin code&lt;/code&gt;를 메인 데이터로 사용하는 방법을 시도해 볼 수 있을 거 같았습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;코드-조회-api를-db-없이-어떻게-만들면-될까요&quot;&gt;코드 조회 API를 DB 없이 어떻게 만들면 될까요?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Kotlin 코드를 &lt;code class=&quot;highlighter-rouge&quot;&gt;reflection&lt;/code&gt; 해서 필요한 코드를 추출해서 기존 DB에서 조회해서 반환하던 response와 동일한 값을 내려줍니다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;실제 사용 예시&lt;/code&gt;에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;object Codes {}&lt;/code&gt;에 확장함수(&lt;code class=&quot;highlighter-rouge&quot;&gt;getCodes&lt;/code&gt;)를 하나 붙여줍니다.&lt;/li&gt;
      &lt;li&gt;대/소문자나 camelCase / snake_case 변환이 필요한 부분은 &lt;a href=&quot;https://github.com/google/guava&quot;&gt;google guava&lt;/a&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;CaseFormat&lt;/code&gt;을 활용했습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;코드 예시(&lt;code class=&quot;highlighter-rouge&quot;&gt;GitHub Gist&lt;/code&gt;): &lt;strong&gt;&lt;a href=&quot;https://gist.github.com/socar-dorma/161c58fda3b848184c62ae287ca59e4b&quot;&gt;&lt;u&gt;reflection을 이용한 공통 코드 조회&lt;/u&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해소된-문제&quot;&gt;해소된 문제&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;이제 공통 코드를 DB에 넣지 않아도 되고, Notion에 Insert 쿼리를 관리하지 않아도 됩니다.&lt;/li&gt;
  &lt;li&gt;공통 코드를 변경한 사실을 팀 내에 따로 전파하지 않아도 Git pull만 받으면 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;3차-javascript에서-사용할-코드-생성&quot;&gt;(3차) JavaScript에서 사용할 코드 생성&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;덧. 글이 너무 길어질 것 같아 &lt;code class=&quot;highlighter-rouge&quot;&gt;Gradle Plugin 만드는 방법 및 사용 방법&lt;/code&gt;은 생략된 부분이 많습니다. 대략적인 작업 흐름을 알 수 있는 정도로 작성하였습니다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/common-code3.png&quot; alt=&quot;공통코드-3차&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;db가-사라졌으니-kotlin-코드를-분석해서-javascript-코드를-생성해-봅시다&quot;&gt;DB가 사라졌으니 Kotlin 코드를 분석해서 JavaScript 코드를 생성해 봅시다.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;팀 내에 프로젝트가 한 개가 아니니 여러 프로젝트에서 공통으로 쓸 수 있었으면 합니다.&lt;/li&gt;
  &lt;li&gt;Gradle Plugin 형태로 만들어서 각 프로젝트에서 사용하고자 합니다.&lt;/li&gt;
  &lt;li&gt;Gradle Plugin에서 프로젝트에 있는 Kotlin 파일에 접근하려니 reflection으로 접근하기가 애매합니다.&lt;/li&gt;
  &lt;li&gt;Gradle Plugin이 실행되는 시점에 프로젝트 코드를 &lt;code class=&quot;highlighter-rouge&quot;&gt;import&lt;/code&gt; 하거나 할 수는 없으니 Gradle Plugin 입장에선 공통코드가 선언된 파일의 경로를 입력받고 파일을 열어서 Kotlin 코드를 파싱해서 쓸 수밖에 없습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;kotlin-코드를-파싱해서-javascript에서-사용할-공통코드-생성하는-gradle-plugin을-만듭니다&quot;&gt;Kotlin 코드를 파싱해서 JavaScript에서 사용할 공통코드 생성하는 Gradle Plugin을 만듭니다.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;reflection은 이미 class가 로딩된 이후에 &lt;a href=&quot;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/&quot;&gt;Kotlin의 KClass&lt;/a&gt;나 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html&quot;&gt;Java의 Class&lt;/a&gt;를 사용하지만 Kotlin PSI의 경우는 전혀 다른 클래스들을 활용하고 별도의 dependency도 필요합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;implementation&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;org.jetbrains.kotlin:kotlin-compiler:1.5.0&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;implementation&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;org.jetbrains.kotlin:kotlin-compiler-embeddable:1.5.0&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#generated_kotlin_code&quot;&gt;(이제 직접 수정하고 있는) 생성된 Kotlin ENUM 코드&lt;/a&gt;에 있는 Kotlin Code를 파싱하는 코드의 대략적인 구조입니다. (&lt;strong&gt;실제 실행되는 코드에서 일부를 발췌한 코드라 바로 실행은 안 됩니다&lt;/strong&gt;)
    &lt;ul&gt;
      &lt;li&gt;JavaScript / TypeScript 코드 생성은 문법에 맞게 문자열을 생성 후 파일로 저장했습니다.&lt;/li&gt;
      &lt;li&gt;코드 예시(&lt;code class=&quot;highlighter-rouge&quot;&gt;GitHub Gist&lt;/code&gt;): &lt;strong&gt;&lt;a href=&quot;https://gist.github.com/socar-dorma/306453fafc0383869f62adf31cfaba0c&quot;&gt;&lt;u&gt;Kotlin PSI로 공통코드 파싱하기&lt;/u&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;만들어진-gradle-plugin의-동작-방식&quot;&gt;만들어진 Gradle Plugin의 동작 방식&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Gradle Plugin을 적용하고 아래 설정을 추가하면 Gradle Task(&lt;code class=&quot;highlighter-rouge&quot;&gt;generate&amp;lt;설정 이름(아래 설정 기준 management)&amp;gt;Code&lt;/code&gt; 유형의 이름으로 생성됨)가 자동으로 추가됩니다.
    &lt;ul&gt;
      &lt;li&gt;각 프로젝트의 &lt;a href=&quot;#generated_kotlin_code&quot;&gt;(이제 직접 수정하고 있는) 생성된 Kotlin Enum 코드&lt;/a&gt;의 절대 경로와 JavaScript 파일을 생성할 절대 경로를 전달합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;codeJavascriptGenerator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;management&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;codeFile&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;${project.rootDir}/subprojects/core/src/main/kotlin/kr/socar/plan/Codes.kt&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;outDir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;${project.rootDir}/subprojects/frontend/management/src/api&quot;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;공통 코드가 수정되면 &lt;code class=&quot;highlighter-rouge&quot;&gt;./gradlew :&amp;lt;project&amp;gt;:generateManagementCode&lt;/code&gt;를 실행해 주면 JavaScript에서 사용할 공통 코드 파일이 생성(갱신)됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;생성된-typescript-코드&quot;&gt;생성된 &lt;code class=&quot;highlighter-rouge&quot;&gt;TypeScript&lt;/code&gt; 코드&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Kotlin에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Codes object&lt;/code&gt;를 사용하는 것과 최대한 동일하게 사용할 수 있도록 코드를 생성했습니다.&lt;/li&gt;
  &lt;li&gt;코드 예시(&lt;code class=&quot;highlighter-rouge&quot;&gt;GitHub Gist&lt;/code&gt;): &lt;strong&gt;&lt;a href=&quot;https://gist.github.com/socar-dorma/a0f2c79be7ffc2cff556c02be80500f0&quot;&gt;&lt;u&gt;생성된 codes.ts 파일&lt;/u&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;javascripttypescript에서-생성된-공통-코드-사용법&quot;&gt;JavaScript(TypeScript)에서 생성된 공통 코드 사용법&lt;/h3&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 공통 코드 가져오기&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Codes&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;`/codes`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 공통 코드 값 비교&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Codes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;settlementType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;AUTO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 공통 코드 =&amp;gt; 라벨 변환&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;STLTP_AUTO&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Codes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;settlementType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;마무리하며&quot;&gt;마무리하며&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;공통 코드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;DB - 서버 - 프론트엔드&lt;/code&gt; 모든 계층에서 폭넓게 사용되며 추가나 수정이 필요한 경우도 많기 때문에 적절하게 관리하고 사용하지 않으면 유지보수나 기능을 추가할 때 큰 문제가 되기도 합니다. 그러므로 공통코드는 각 계층에서 사용하는 프로그래밍 언어 각각에서 상수로 정의해서 사용해야 하고 각 계층 간에 동기화도 쉬워야 한다고 생각합니다.&lt;/li&gt;
  &lt;li&gt;서두에 적었듯이 &lt;code class=&quot;highlighter-rouge&quot;&gt;공통 코드 관리 방법에 정답은 없다&lt;/code&gt;고 생각합니다(저희 팀도 추가 수정을 할 수도 있습니다)&lt;/li&gt;
  &lt;li&gt;저희 팀은 이런 과정을 거쳐서 이렇게 사용하고 있다는 경험을 공유해 드리는 것뿐 당연히 이 방법도 정답은 아닙니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DB - 서버 - 프론트엔드&lt;/code&gt;에 걸쳐서 공통코드를 어떤 식으로 관리할지 고민하시는 분들에게 참고가 되었으면 좋겠습니다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Gradle Plugin 만드는 과정&lt;/code&gt;은 이 글 주제에서는 중요도가 낮다고 생각되어서 대략적인 내용만 적었습니다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>dorma</name></author><category term="dev" /><category term="공통코드관리" /><summary type="html">저희 팀은 쏘카 R&amp;amp;D 본부에서 다양한 백오피스 개발을 담당하고 있습니다. 백오피스 개발에 사용되는 기술 스택은 다음과 같습니다.</summary></entry></feed>